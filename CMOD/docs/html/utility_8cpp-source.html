<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CMOD: utility.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>utility.cpp</h1><a href="utility_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">CMOD (composition module)</span>
00003 <span class="comment">Copyright (C) 2005  Sever Tipei (s-tipei@uiuc.edu)</span>
00004 <span class="comment">                                                                                </span>
00005 <span class="comment">This program is free software; you can redistribute it and/or</span>
00006 <span class="comment">modify it under the terms of the GNU General Public License</span>
00007 <span class="comment">as published by the Free Software Foundation; either version 2</span>
00008 <span class="comment">of the License, or (at your option) any later version.</span>
00009 <span class="comment">                                                                                </span>
00010 <span class="comment">This program is distributed in the hope that it will be useful,</span>
00011 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00012 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00013 <span class="comment">GNU General Public License for more details.</span>
00014 <span class="comment">                                                                                </span>
00015 <span class="comment">You should have received a copy of the GNU General Public License</span>
00016 <span class="comment">along with this program; if not, write to the Free Software</span>
00017 <span class="comment">Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
00018 <span class="comment">*/</span>
00019 
00020 <span class="comment">//----------------------------------------------------------------------------//</span>
00021 <span class="comment">// utility.cpp</span>
00022 <span class="comment">//----------------------------------------------------------------------------//</span>
00023 
00024 <span class="comment">//----------------------------------------------------------------------------//</span>
00025 <span class="comment">// Includes</span>
00026 <span class="comment">//----------------------------------------------------------------------------//</span>
00027 <span class="preprocessor">#include "../../LASS/src/lib.h"</span>
00028 
00029 <span class="preprocessor">#include "<a class="code" href="dataIn_8h.html">dataIn.h</a>"</span>
00030 <span class="preprocessor">#include "<a class="code" href="define_8h.html">define.h</a>"</span>
00031 <span class="preprocessor">#include "<a class="code" href="linkList_8h.html">linkList.h</a>"</span>
00032 <span class="preprocessor">#include "<a class="code" href="patter_8h.html">patter.h</a>"</span>
00033 <span class="preprocessor">#include "<a class="code" href="sieve_8h.html">sieve.h</a>"</span>
00034 <span class="preprocessor">#include "<a class="code" href="utility_8h.html">utility.h</a>"</span>
00035 <span class="preprocessor">#include &lt;list&gt;</span>
00036 <span class="preprocessor">#include "<a class="code" href="random_8h.html">random.h</a>"</span>
00037 
00038 <span class="preprocessor">#include &lt;math.h&gt;</span>
00039 <span class="preprocessor">#include &lt;sstream&gt;</span>
00040 <span class="preprocessor">#include &lt;iostream&gt;</span>
00041 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00042 
00043 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00044 <span class="comment">//----------------------------------------------------------------------------//</span>
00045 <span class="comment">// Global Variables</span>
00046 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00047"></a><a class="code" href="utility_8cpp.html#a0">00047</a> <span class="keywordtype">int</span> *<a class="code" href="utility_8cpp.html#a0">table</a>;
<a name="l00048"></a><a class="code" href="utility_8cpp.html#a1">00048</a> <span class="keywordtype">int</span> <a class="code" href="utility_8cpp.html#a1">tableSize</a>;
00049 <span class="comment">//----------------------------------------------------------------------------//</span>
00050 
00051 <span class="comment">//----------------------------------------------------------------------------//</span>
00052 <span class="comment">/* </span>
00053 <span class="comment">   ValuePick</span>
00054 <span class="comment">   </span>
00055 <span class="comment">   This is the deprecated version, see the version below</span>
00056 <span class="comment">   for the new implementation</span>
00057 <span class="comment">*/</span>
<a name="l00058"></a><a class="code" href="utility_8cpp.html#a2">00058</a> <span class="keywordtype">int</span> <a class="code" href="utility_8cpp.html#a2">ValuePick</a> (<span class="keywordtype">double</span> checkPoint, <span class="keywordtype">float</span> absRange) {
00059     cout&lt;&lt;<span class="stringliteral">"ValuePick called, why?"</span>&lt;&lt;endl;
00060     <span class="comment">/*</span>
00061 <span class="comment">  int limit[2], value;</span>
00062 <span class="comment">  char * method;</span>
00063 <span class="comment"></span>
00064 <span class="comment">  DataIn vP; vP.ReadDummies();</span>
00065 <span class="comment"></span>
00066 <span class="comment">  vP.ReadInts(3);       // envelope numbers</span>
00067 <span class="comment">  vP.ReadFloats(3);     // scaling factors</span>
00068 <span class="comment"></span>
00069 <span class="comment">  // Find the lower and upper limits</span>
00070 <span class="comment">  cout &lt;&lt; "Utility - ValuePick:" &lt;&lt; endl;</span>
00071 <span class="comment"></span>
00072 <span class="comment">  for(int i = 0; i &lt; 2; i++) {</span>
00073 <span class="comment">    // USING NEW EnvelopeBuilder NOW</span>
00074 <span class="comment">    Envelope *env = EnvelopeBuilder("FROM_LIB_NUM", NULL, NULL, 0, 0,</span>
00075 <span class="comment">        0, vP.intVect[i]);</span>
00076 <span class="comment">    limit [i] = (int) floor (env-&gt;GetScaledValueNew(checkPoint,</span>
00077 <span class="comment">        vP.floatVect[i]) * absRange + 0.5);</span>
00078 <span class="comment"></span>
00079 <span class="comment">    // HERE'S THE OLD WAY</span>
00080 <span class="comment">    /*limit[i] = (int) floor (envValue (checkPoint, vP.intVect[i],</span>
00081 <span class="comment">        vP.floatVect[i]) * absRange + 0.5);*</span>
00082 <span class="comment">    cout &lt;&lt; "limit[" &lt;&lt; i &lt;&lt; "]=" &lt;&lt; limit[i] &lt;&lt; " ";</span>
00083 <span class="comment">  }</span>
00084 <span class="comment"></span>
00085 <span class="comment">  cout &lt;&lt; " checkPoint=" &lt;&lt; checkPoint &lt;&lt; " absRange=" &lt;&lt; absRange &lt;&lt; endl;</span>
00086 <span class="comment">  cin &gt;&gt; sever;</span>
00087 <span class="comment"></span>
00088 <span class="comment">  Sieve si;                                             // create a sieve</span>
00089 <span class="comment">  si.Build(limit[0], limit[1]);                         // elements &amp; weights</span>
00090 <span class="comment">  value = si.Modify(vP.intVect[2], vP.floatVect[2]);    // envelope, choose</span>
00091 <span class="comment"></span>
00092 <span class="comment">  return value;</span>
00093 <span class="comment">  */</span>
00094 }
00095 <span class="comment">/*</span>
00096 <span class="comment">   ValuePick</span>
00097 <span class="comment">   </span>
00098 <span class="comment">   This function uses two vectors, storing the elements possible and the weights</span>
00099 <span class="comment">   associated with those weights to be used with a sieve.  The upper and lower limits </span>
00100 <span class="comment">   are set using the information in envLow and envHigh, and scaled by a factor of</span>
00101 <span class="comment">   absRange.  A value from the sieve is chosen and returned.</span>
00102 <span class="comment">*/</span>
<a name="l00103"></a><a class="code" href="utility_8cpp.html#a3">00103</a> <span class="keywordtype">int</span> <a class="code" href="utility_8cpp.html#a3">valuePick</a>(<span class="keywordtype">double</span> checkpoint, <span class="keywordtype">float</span> absRange, Envelope *envLow, 
00104               Envelope *envHigh, Envelope *envDist, <span class="keyword">const</span> <span class="keywordtype">char</span> *eMethod,
00105               vector&lt;int&gt; eArgVect, <span class="keyword">const</span> <span class="keywordtype">char</span> *wMethod, 
00106               vector&lt;int&gt; wArgVect, <span class="keyword">const</span> <span class="keywordtype">char</span> *modifyMethod)
00107 {
00108     <span class="keywordtype">int</span> limit[2];
00109     <span class="keywordtype">int</span> value;
00110     limit[0] =
00111         (<span class="keywordtype">int</span>)floor((envLow-&gt;GetScaledValueNew(checkpoint, 1))*absRange + 0.5);
00112     limit[1] =
00113         (<span class="keywordtype">int</span>)floor((envHigh-&gt;GetScaledValueNew(checkpoint, 1))*absRange + 0.5);
00114     
00115     <a class="code" href="classSieve.html">Sieve</a> si;                                             <span class="comment">// create a sieve</span>
00116     si.<a class="code" href="classSieve.html#a3">Build</a>(limit[0], limit[1], eMethod, 
00117              wMethod, eArgVect, wArgVect);       <span class="comment">// elements &amp; weights</span>
00118     value = si.<a class="code" href="classSieve.html#a6">Modify</a>(envDist, modifyMethod);    <span class="comment">// envelope, choose</span>
00119 
00120     <span class="keywordflow">return</span> value;
00121 }
00122 <span class="comment">//----------------------------------------------------------------------------//</span>
00123 
00124 
00125 <span class="comment">//----------------------------------------------------------------------------//</span>
00126 <span class="comment">/*</span>
00127 <span class="comment">   ValueFloat</span>
00128 <span class="comment">   </span>
00129 <span class="comment">   This function takes in 2 arrays, containing the upper bound and lower bound of</span>
00130 <span class="comment">   the value wishing to be obtained, as well as a third element. These are used</span>
00131 <span class="comment">  to return a random number within the range set out by the bounds.</span>
00132 <span class="comment">*/</span>
<a name="l00133"></a><a class="code" href="utility_8cpp.html#a4">00133</a> <span class="keywordtype">float</span> <a class="code" href="utility_8cpp.html#a5">ValueFloat</a>(<span class="keywordtype">double</span> checkPoint, <span class="keywordtype">int</span> envNum[], <span class="keywordtype">float</span> coef[]) {
00134   <span class="keywordtype">float</span> limit [2], valueF;
00135 
00136   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; i++) {
00137     <span class="comment">// USING NEW EnvelopeBuilder NOW</span>
00138     Envelope *env = <a class="code" href="utility_8h.html#a19">EnvelopeBuilder</a>(<span class="stringliteral">"FROM_LIB_NUM"</span>, NULL, NULL, 0, 0,
00139         0, envNum[i]);
00140     limit [i] = env-&gt;GetScaledValueNew(checkPoint, coef[i]);
00141 
00142     <span class="comment">// HERE'S THE OLD WAY</span>
00143     <span class="comment">//limit [i] = envValue (checkPoint, envNum[i], coef[i]);</span>
00144   }
00145 
00146   <span class="keywordtype">double</span> randomNumber = <a class="code" href="classRandom.html#e1">Random::Rand</a>();
00147 
00148   <span class="comment">// USING NEW EnvelopeBuilder NOW</span>
00149   Envelope *env = <a class="code" href="utility_8h.html#a19">EnvelopeBuilder</a>(<span class="stringliteral">"FROM_LIB_NUM"</span>, NULL, NULL, 0, 0,
00150     0, envNum[2]);
00151   valueF = env-&gt;GetScaledValueNew(randomNumber, coef[2]);
00152 
00153   <span class="comment">// HERE'S THE OLD WAY</span>
00154   <span class="comment">//valueF = envValue (randomNumber, envNum[2], coef[2]);</span>
00155 
00156   valueF *= (limit [1] - limit [0]);
00157   valueF += limit [0];
00158 
00159   <span class="keywordflow">return</span> valueF;
00160 }
00161 
00162 <span class="comment">/*</span>
00163 <span class="comment">   ValueFloat</span>
00164 <span class="comment">   </span>
00165 <span class="comment">   This function takes in 2 vectors, containing the upper bound and lower bound of</span>
00166 <span class="comment">   the value wishing to be obtained, as well as a third element. These are used</span>
00167 <span class="comment">   to return a random number within the range set out by the bounds.</span>
00168 <span class="comment">*/</span>
<a name="l00169"></a><a class="code" href="utility_8cpp.html#a5">00169</a> <span class="keywordtype">float</span> <a class="code" href="utility_8cpp.html#a5">ValueFloat</a>(<span class="keywordtype">double</span> checkPoint, vector&lt;int&gt; envNum, vector&lt;float&gt; coef) {
00170   <span class="keywordtype">float</span> limit [2], valueF;
00171 
00172   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; i++) {
00173     <span class="comment">// USING NEW EnvelopeBuilder NOW</span>
00174     Envelope *env = <a class="code" href="utility_8h.html#a19">EnvelopeBuilder</a>(<span class="stringliteral">"FROM_LIB_NUM"</span>, NULL, NULL, 0, 0,
00175         0, envNum[i]);
00176     limit [i] = env-&gt;GetScaledValueNew(checkPoint, coef[i]);
00177 
00178     <span class="comment">// HERE'S THE OLD WAY</span>
00179     <span class="comment">//limit [i] = envValue (checkPoint, envNum[i], coef[i]);</span>
00180   }
00181 
00182   <span class="keywordtype">double</span> randomNumber = <a class="code" href="classRandom.html#e1">Random::Rand</a>();
00183 
00184   <span class="comment">// USING NEW EnvelopeBuilder NOW</span>
00185   Envelope *env = <a class="code" href="utility_8h.html#a19">EnvelopeBuilder</a>(<span class="stringliteral">"FROM_LIB_NUM"</span>, NULL, NULL, 0, 0,
00186     0, envNum[2]);
00187   valueF = env-&gt;GetScaledValueNew(randomNumber, coef[2]);
00188 
00189   <span class="comment">// HERE'S THE OLD WAY</span>
00190   <span class="comment">//valueF = envValue (randomNumber, envNum[2], coef[2]);</span>
00191 
00192   valueF *= (limit [1] - limit [0]);
00193   valueF += limit [0];
00194 
00195   <span class="keywordflow">return</span> valueF;
00196 }
00197 
00198 <span class="comment">//----------------------------------------------------------------------------//</span>
00199 
00200 
00201 <span class="comment">//----------------------------------------------------------------------------//</span>
00202 <span class="comment">/*</span>
00203 <span class="comment">   Choose</span>
00204 <span class="comment"></span>
00205 <span class="comment">   This function takes in lower and upper bounds, and retuns a random </span>
00206 <span class="comment">   double from the range provided.  Each possibility is equally weighted in this</span>
00207 <span class="comment">   function.</span>
00208 <span class="comment">*/</span>
<a name="l00209"></a><a class="code" href="utility_8cpp.html#a6">00209</a> <span class="keywordtype">double</span> <a class="code" href="utility_8cpp.html#a6">Choose</a>(<span class="keywordtype">double</span> from, <span class="keywordtype">double</span> to) {
00210   <span class="keywordtype">double</span> randomNumber = <a class="code" href="classRandom.html#e1">Random::Rand</a>();
00211   <span class="keywordtype">double</span> chosen = (to - from) * randomNumber + from;
00212 
00213   <span class="keywordflow">return</span> chosen;
00214 }
00215 <span class="comment">//----------------------------------------------------------------------------//</span>
00216 
00217 
00218 <span class="comment">//----------------------------------------------------------------------------//</span>
00219 <span class="comment">/*</span>
00220 <span class="comment">   CumulArray</span>
00221 <span class="comment">   </span>
00222 <span class="comment">   This function takes in an array of length size, and transforms the array into</span>
00223 <span class="comment">   an array where each element is the sum of the weights of the original array element</span>
00224 <span class="comment">   with the same index as itself and all previous elements from the original array.</span>
00225 <span class="comment">*/</span>
<a name="l00226"></a><a class="code" href="utility_8cpp.html#a7">00226</a> <span class="keywordtype">void</span> <a class="code" href="utility_8cpp.html#a7">CumulArray</a>(<span class="keywordtype">double</span> array[], <span class="keywordtype">int</span> size) {
00227   <span class="keywordtype">double</span> partSum = 0;
00228 
00229   <a class="code" href="utility_8cpp.html#a32">Normalize</a>(array, size);
00230 
00231   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00232     partSum += array[i];
00233     array[i] = partSum;
00234   }
00235 }
00236 <span class="comment">//----------------------------------------------------------------------------//</span>
00237 
00238 
00239 <span class="comment">//----------------------------------------------------------------------------//</span>
00240 <span class="comment">/*</span>
00241 <span class="comment">   CumulWeights</span>
00242 <span class="comment">   </span>
00243 <span class="comment">   This function takes in a list, and transforms the list into one where each element</span>
00244 <span class="comment">   is the sum of the weights of the original list element with the same position as itself</span>
00245 <span class="comment">   and all previous elements from the original list.</span>
00246 <span class="comment">*/</span>
<a name="l00247"></a><a class="code" href="utility_8cpp.html#a8">00247</a> <span class="keywordtype">void</span> <a class="code" href="utility_8cpp.html#a8">CumulWeights</a>(<a class="code" href="classList.html">List&lt;double&gt;</a> &amp;wList) {
00248   <span class="keywordtype">double</span> cumul = 0, sum;
00249   <span class="keywordtype">double</span> value;
00250 
00251   <span class="keywordtype">int</span> len = wList.<a class="code" href="classList.html#a17">Length</a>();
00252   wList.<a class="code" href="classList.html#a25">Normalize</a>();
00253   wList.<a class="code" href="classList.html#a11">Head</a>();
00254 
00255   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt;= len; i++) {
00256     value = wList.<a class="code" href="classList.html#a15">Retrieve</a>();
00257     cumul += value;
00258     wList.<a class="code" href="classList.html#a10">Update</a>(cumul);
00259     wList++;
00260   }
00261 }
00262 <span class="comment">//----------------------------------------------------------------------------//</span>
00263 
00264 
00265 <span class="comment">//----------------------------------------------------------------------------//</span>
00266 <span class="comment">/*</span>
00267 <span class="comment">   CumulWeights</span>
00268 <span class="comment">   </span>
00269 <span class="comment">   This function takes in two lists of the same length, and randomly chooses one </span>
00270 <span class="comment">   element from the second list to return.</span>
00271 <span class="comment">*/</span>
<a name="l00272"></a><a class="code" href="utility_8cpp.html#a9">00272</a> <span class="keywordtype">int</span> <a class="code" href="utility_8cpp.html#a9">ChooseL</a>(<a class="code" href="classList.html">List&lt;double&gt;</a> &amp; aList, <a class="code" href="classList.html">List&lt;int&gt;</a> &amp; bList) {
00273 
00274   <span class="keywordtype">double</span> randomNumber = <a class="code" href="classRandom.html#e1">Random::Rand</a>();
00275   aList.<a class="code" href="classList.html#a11">Head</a>();
00276   bList.<a class="code" href="classList.html#a11">Head</a>();
00277 
00278   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; aList.<a class="code" href="classList.html#a17">Length</a>(); i++) {
00279     <span class="keywordflow">if</span>(randomNumber &gt; aList.<a class="code" href="classList.html#a15">Retrieve</a>()) {
00280       bList++;
00281       aList++;
00282     }
00283   }
00284 
00285   <span class="keywordflow">return</span> bList.<a class="code" href="classList.html#a15">Retrieve</a>();
00286 }
00287 <span class="comment">//----------------------------------------------------------------------------//</span>
00288 
00289 
00290 <span class="comment">//----------------------------------------------------------------------------//</span>
00291 
00292 <span class="comment">/* (hopefully) been replaced by the new version which uses arguments</span>
00293 <span class="comment"> * instead of reading from the file</span>
00294 <span class="comment">float Stochos(double checkPoint, int offset) {</span>
00295 <span class="comment">  int num;                      // number of envelopes</span>
00296 <span class="comment">  float val;</span>
00297 <span class="comment">  double randomNumber;</span>
00298 <span class="comment">  char * method;</span>
00299 <span class="comment"></span>
00300 <span class="comment">  DataIn st; st.ReadDummies();</span>
00301 <span class="comment">  st.ReadChars(1);              // method used</span>
00302 <span class="comment">  st.ReadInts(1);               // num envelopes</span>
00303 <span class="comment">  method = st.nameOf[0];</span>
00304 <span class="comment">  num = st.intVect[0];</span>
00305 <span class="comment"></span>
00306 <span class="comment">  st.ReadInts(num);             // envelope numbers</span>
00307 <span class="comment">  st.ReadFloats(num);           // scale factors</span>
00308 <span class="comment"></span>
00309 <span class="comment">  // stacked up envelopes: their values at the same moment add up to 1</span>
00310 <span class="comment">  if(strcmp(method, "FUNCTIONS") == 0) { </span>
00311 <span class="comment"></span>
00312 <span class="comment">    for (int i = 0; i &lt; num; i++) {</span>
00313 <span class="comment">      /* USING NEW EnvelopeBuilder NOW *</span>
00314 <span class="comment">      Envelope *env = EnvelopeBuilder("FROM_LIB_NUM", NULL, NULL, 0, 0, 0, st.intVect[i]);</span>
00315 <span class="comment">      val = env-&gt;GetScaledValueNew(checkPoint, st.floatVect[i]);</span>
00316 <span class="comment"></span>
00317 <span class="comment">      /* HERE'S THE OLD WAY *</span>
00318 <span class="comment">      //val = envValue(checkPoint, st.intVect[i], st.floatVect[i]);</span>
00319 <span class="comment"></span>
00320 <span class="comment">      if(num &gt; 1) {             // probability areas</span>
00321 <span class="comment">        if(i == 0) randomNumber = RandomSource();</span>
00322 <span class="comment">        if (val &gt;= randomNumber) return i;</span>
00323 <span class="comment">      } </span>
00324 <span class="comment">    }</span>
00325 <span class="comment"></span>
00326 <span class="comment">  // distribution within given range; takes 3 envs: min, MAX, value in between</span>
00327 <span class="comment">  } else if (strcmp(method, "RANGE_DISTRIB") == 0) { </span>
00328 <span class="comment">    val = ValueFloat(checkPoint, st.intVect + 3 * offset, st.floatVect + 3 </span>
00329 <span class="comment">        * offset);</span>
00330 <span class="comment">  }</span>
00331 <span class="comment"></span>
00332 <span class="comment">  //cout &lt;&lt; "Stochos - val=" &lt;&lt; val &lt;&lt; endl;</span>
00333 <span class="comment"></span>
00334 <span class="comment">  return val;</span>
00335 <span class="comment">} */</span>
00336 
00337 <span class="comment">/* This version looks up envNums in the library, and then scales it</span>
00338 <span class="comment"> * rather than taking the scaled envelopes as parameters. Probably is</span>
00339 <span class="comment"> * not needed anymore.</span>
00340 <span class="comment"></span>
00341 <span class="comment">float Stochos(double checkPoint, int offset, const char *method,</span>
00342 <span class="comment">              vector&lt;int&gt; envNums, vector&lt;float&gt; scale) {</span>
00343 <span class="comment">  float val;</span>
00344 <span class="comment">  double randomNumber;</span>
00345 <span class="comment"></span>
00346 <span class="comment">  // stacked up envelopes: their values at the same moment add up to 1</span>
00347 <span class="comment">  if(strcmp(method, "FUNCTIONS") == 0) { </span>
00348 <span class="comment"></span>
00349 <span class="comment">    for (int i = 0; i &lt; envNums.size(); i++) {</span>
00350 <span class="comment">      /* USING NEW EnvelopeBuilder NOW *</span>
00351 <span class="comment">      Envelope *env = EnvelopeBuilder("FROM_LIB_NUM", NULL, NULL, 0, 0, 0, envNums[i]);</span>
00352 <span class="comment">      val = env-&gt;GetScaledValueNew(checkPoint, scale[i]);</span>
00353 <span class="comment"></span>
00354 <span class="comment">      /* HERE'S THE OLD WAY *</span>
00355 <span class="comment">      //val = envValue(checkPoint, st.intVect[i], st.floatVect[i]);</span>
00356 <span class="comment"></span>
00357 <span class="comment">      if(envNums.size() &gt; 1) {             // probability areas</span>
00358 <span class="comment">        if(i == 0) randomNumber = RandomSource();</span>
00359 <span class="comment">        if (val &gt;= randomNumber) return i;</span>
00360 <span class="comment">      } </span>
00361 <span class="comment">    }</span>
00362 <span class="comment"></span>
00363 <span class="comment">  // distribution within given range; takes 3 envs: min, MAX, value in between</span>
00364 <span class="comment">  } else if (strcmp(method, "RANGE_DISTRIB") == 0) { </span>
00365 <span class="comment">    val = ValueFloat(checkPoint, vector&lt;int&gt;(envNums.begin()+(3*offset), envNums.end()),</span>
00366 <span class="comment">            vector&lt;float&gt;(scale.begin()+(3*offset), scale.end()));</span>
00367 <span class="comment">//    val = ValueFloat(checkPoint, st.intVect + 3 * offset, st.floatVect + 3 </span>
00368 <span class="comment">//        * offset);</span>
00369 <span class="comment">  }</span>
00370 <span class="comment"></span>
00371 <span class="comment">  //cout &lt;&lt; "Stochos - val=" &lt;&lt; val &lt;&lt; endl;</span>
00372 <span class="comment"></span>
00373 <span class="comment">  return val;</span>
00374 <span class="comment">} </span>
00375 <span class="comment">*/</span>
00376 
00377 <span class="comment">/* The most current version of Stochos */</span>
00378 <span class="comment">/*</span>
00379 <span class="comment">   Stochos</span>
00380 <span class="comment">   </span>
00381 <span class="comment">   This function takes in an list, and transforms the list into one where each element </span>
00382 <span class="comment">   is the sum of the weights of the original list element with the same position as itself</span>
00383 <span class="comment">   and all previous elements from the original list.</span>
00384 <span class="comment">*/</span>
<a name="l00385"></a><a class="code" href="utility_8cpp.html#a10">00385</a> <span class="keywordtype">float</span> <a class="code" href="utility_8cpp.html#a10">Stochos</a>(<span class="keywordtype">double</span> checkPoint, <span class="keywordtype">int</span> offset, <span class="keyword">const</span> <span class="keywordtype">char</span> *method,
00386               vector&lt;Envelope*&gt; envNums) {
00387   <span class="keywordtype">float</span> val;
00388   <span class="keywordtype">double</span> randomNumber;
00389 
00390   <span class="comment">// stacked up envelopes: their values at the same moment add up to 1</span>
00391   <span class="keywordflow">if</span>(strcmp(method, <span class="stringliteral">"FUNCTIONS"</span>) == 0) { 
00392 
00393     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; envNums.size(); i++) {
00394       <span class="comment">/* USING NEW EnvelopeBuilder NOW */</span>
00395       val = envNums[i]-&gt;GetScaledValueNew(checkPoint,1);
00396 
00397       <span class="comment">/* HERE'S THE OLD WAY */</span> 
00398       <span class="comment">//val = envValue(checkPoint, st.intVect[i], st.floatVect[i]);</span>
00399 
00400       <span class="keywordflow">if</span>(envNums.size() &gt; 1) {             <span class="comment">// probability areas</span>
00401         <span class="keywordflow">if</span>(i == 0) randomNumber = <a class="code" href="classRandom.html#e1">Random::Rand</a>();
00402         <span class="keywordflow">if</span> (val &gt;= randomNumber) <span class="keywordflow">return</span> i;
00403       } 
00404     }
00405 
00406   <span class="comment">// distribution within given range; takes 3 envs: min, MAX, value in between</span>
00407   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(method, <span class="stringliteral">"RANGE_DISTRIB"</span>) == 0) { 
00408 <span class="comment">//    val = ValueFloat(checkPoint, vector&lt;int&gt;(envNums.begin()+(3*offset), envNums.end()),</span>
00409 <span class="comment">//            vector&lt;float&gt;(scale.begin()+(3*offset), scale.end()));</span>
00410 <span class="comment">//    val = ValueFloat(checkPoint, st.intVect + 3 * offset, st.floatVect + 3 </span>
00411 <span class="comment">//        * offset);</span>
00412 
00413       <span class="keywordtype">float</span> limit[2], valueF;
00414       <span class="keywordflow">if</span>(2 + 3*offset &gt;= envNums.size())
00415       {
00416           cout&lt;&lt;<span class="stringliteral">"Not enough elements in list of envelopes. Fix me."</span>&lt;&lt;endl;
00417           <span class="keywordflow">return</span> 0;
00418       }
00419       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt;2; i++)
00420       {
00421           <span class="keywordflow">if</span>(envNums[i + 3*offset])
00422               limit[i] = envNums[i + 3*offset]-&gt;getValue(checkPoint,1);
00423           <span class="keywordflow">else</span> {
00424               cout&lt;&lt;<span class="stringliteral">"NULL envelope. Why do you do this to me?"</span>
00425                  &lt;&lt;<span class="stringliteral">" do you hate me that much?"</span>&lt;&lt;endl;
00426               cout&lt;&lt;<span class="stringliteral">"trying to access envNums["</span>&lt;&lt;i + 3*offset&lt;&lt;<span class="stringliteral">"]."</span>&lt;&lt;endl;
00427               printf(<span class="stringliteral">"envNums[%i] = %p\n"</span>, 
00428                       i+3*offset, envNums[i+3*offset]);
00429           }
00430       }
00431       <span class="keywordflow">if</span>(envNums[2 + 3*offset])
00432           valueF = envNums[2 + 3*offset]-&gt;getValue(checkPoint,1);
00433       <span class="keywordflow">else</span> {
00434           cout&lt;&lt;<span class="stringliteral">"NULL envelope. Why do you do this to me?"</span>
00435               &lt;&lt;<span class="stringliteral">" do you hate me that much?"</span>&lt;&lt;endl;
00436           cout&lt;&lt;<span class="stringliteral">"trying to access envNums["</span>&lt;&lt;2+3*offset&lt;&lt;<span class="stringliteral">"]."</span>&lt;&lt;endl;
00437           printf(<span class="stringliteral">"envNums[%i] = %p\n"</span>, 
00438                   2+3*offset, envNums[2+3*offset]);
00439 
00440       }
00441 
00442       valueF *= (limit[1] - limit[0]);
00443       valueF += limit[0];
00444   }
00445 
00446   <span class="comment">//cout &lt;&lt; "Stochos - val=" &lt;&lt; val &lt;&lt; endl;</span>
00447 
00448   <span class="keywordflow">return</span> val;
00449 }
00450 
00451 
00452 <span class="comment">//----------------------------------------------------------------------------//</span>
00453 
00454 <span class="comment">/* these functions should not be called. They are turned into Noop's to make</span>
00455 <span class="comment"> * sure the program will complie.</span>
00456 <span class="comment"> */</span>
00457 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00458"></a><a class="code" href="utility_8cpp.html#a11">00458</a> <span class="keywordtype">int</span> <a class="code" href="utility_8cpp.html#a11">ReadComputeInt</a>(<span class="keywordtype">double</span> checkPoint, <span class="keywordtype">int</span> offset) {
00459     cout&lt;&lt;<span class="stringliteral">"ReadComputeInt called, why?"</span>&lt;&lt;endl;
00460     <span class="comment">/*</span>
00461 <span class="comment">  int size, value;</span>
00462 <span class="comment">  float absRange;</span>
00463 <span class="comment">  char * method;</span>
00464 <span class="comment"></span>
00465 <span class="comment">  DataIn rcI; rcI.ReadDummies();</span>
00466 <span class="comment">  rcI.ReadChars(1);</span>
00467 <span class="comment">  method = rcI.nameOf[0];               // which method</span>
00468 <span class="comment"></span>
00469 <span class="comment">  //cout &lt;&lt; "ReadComputeInt - method: " &lt;&lt; method &lt;&lt; endl;</span>
00470 <span class="comment"></span>
00471 <span class="comment">  if(strcmp(method, "SEQUENCE") == 0) {</span>
00472 <span class="comment">    value = (int)Sequence(offset);</span>
00473 <span class="comment">  } else if(strcmp(method, "COMPUTE") == 0) {</span>
00474 <span class="comment">    rcI.ReadInts(1);</span>
00475 <span class="comment">    absRange = rcI.intVect[0];</span>
00476 <span class="comment">    value = ValuePick(checkPoint, absRange);</span>
00477 <span class="comment">  } else if(strcmp(method, "CHOOSE_LIST") == 0) {</span>
00478 <span class="comment">    rcI.ReadInts(1);                    // read size</span>
00479 <span class="comment">    size = rcI.intVect[0];</span>
00480 <span class="comment">    rcI.GenFloats(size);                // read list</span>
00481 <span class="comment">    value = (int)ChooseFromList(rcI.gFloatVect, size);</span>
00482 <span class="comment">  } else if(strcmp(method, "SIMPLE_IRAND") == 0) {</span>
00483 <span class="comment">    rcI.ReadInts(2);</span>
00484 <span class="comment">    value = RandomNumber(rcI.intVect[0], rcI.intVect[1]);</span>
00485 <span class="comment">  } else {</span>
00486 <span class="comment">    cout &lt;&lt; "Utility::ReadComputeInt - NO method specified" &lt;&lt; endl;</span>
00487 <span class="comment">    cin &gt;&gt; sever;</span>
00488 <span class="comment">  }</span>
00489 <span class="comment">  return value;</span>
00490 <span class="comment">  */</span>
00491 }
00492 <span class="comment">//----------------------------------------------------------------------------//</span>
00493 
00494 
00495 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00496"></a><a class="code" href="utility_8cpp.html#a12">00496</a> <span class="keywordtype">float</span> <a class="code" href="utility_8cpp.html#a12">ReadComputeFloat</a>(<span class="keywordtype">double</span> checkPoint, <span class="keywordtype">int</span> offset) {
00497     cout&lt;&lt;<span class="stringliteral">"ReadComputeFloat called, why?"</span>&lt;&lt;endl;
00498     <span class="comment">/*</span>
00499 <span class="comment">  int size;</span>
00500 <span class="comment">  float value;</span>
00501 <span class="comment">  char * method;</span>
00502 <span class="comment"></span>
00503 <span class="comment">  DataIn rcF; rcF.ReadDummies();</span>
00504 <span class="comment">  rcF.ReadChars(1);</span>
00505 <span class="comment">  method = rcF.nameOf[0];                   // which method</span>
00506 <span class="comment"></span>
00507 <span class="comment">  if(strcmp(method, "SEQUENCE") == 0) {</span>
00508 <span class="comment">    value = Sequence(offset);</span>
00509 <span class="comment">  } else if(strcmp(method, "COMPUTE") == 0) {</span>
00510 <span class="comment">    value = Stochos(checkPoint, offset);</span>
00511 <span class="comment">  } else if(strcmp(method, "CHOOSE_LIST") == 0) {</span>
00512 <span class="comment">    rcF.ReadInts(1);                        // read size</span>
00513 <span class="comment">    size = rcF.intVect[0];</span>
00514 <span class="comment">    rcF.GenFloats(size);                    // read list</span>
00515 <span class="comment">    value = ChooseFromList(rcF.gFloatVect, size);</span>
00516 <span class="comment">  } else if(strcmp(method, "SIMPLE_FRAND") == 0) {</span>
00517 <span class="comment">    rcF.ReadFloats(2);</span>
00518 <span class="comment">    value = (float)RandRange(rcF.floatVect[0], rcF.floatVect[1]);</span>
00519 <span class="comment">  } else {</span>
00520 <span class="comment">    cout &lt;&lt; "Utility::ReadComputeFloat (" &lt;&lt; rcF.cAr &lt;&lt; ") - NO method specified"</span>
00521 <span class="comment">      &lt;&lt; endl;</span>
00522 <span class="comment">    cin &gt;&gt; sever;</span>
00523 <span class="comment">  }</span>
00524 <span class="comment"></span>
00525 <span class="comment">  //cout &lt;&lt; "Utility::ReadComputeFloat - value=" &lt;&lt; value &lt;&lt; endl;</span>
00526 <span class="comment"></span>
00527 <span class="comment">  return value;</span>
00528 <span class="comment">  */</span>
00529 }
00530 <span class="comment">//----------------------------------------------------------------------------//</span>
00531 
00532 
00533 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00534"></a><a class="code" href="utility_8cpp.html#a13">00534</a> <span class="keywordtype">void</span> <a class="code" href="utility_8cpp.html#a13">NonReadCompute</a>() {
00535     cout&lt;&lt;<span class="stringliteral">"NonReadCompute called, why?"</span>&lt;&lt;endl;
00536     <span class="comment">/*</span>
00537 <span class="comment">  char * method;</span>
00538 <span class="comment"></span>
00539 <span class="comment">  DataIn NonR;</span>
00540 <span class="comment"></span>
00541 <span class="comment">  NonR.ReadDummies();</span>
00542 <span class="comment">  NonR.ReadChars(1);</span>
00543 <span class="comment">  method = NonR.nameOf[0];</span>
00544 <span class="comment">  // cout &lt;&lt; "NonReadCompute - method: " &lt;&lt; method &lt;&lt; endl;</span>
00545 <span class="comment"></span>
00546 <span class="comment">  if(strcmp(method, "SEQUENCE") == 0) {</span>
00547 <span class="comment">    NonR.Skip(1);</span>
00548 <span class="comment">    // NonR.ReadInts(1);</span>
00549 <span class="comment">    // NonR.GenFloats(NonR.intVect[0]);</span>
00550 <span class="comment">  } else if(strcmp(method, "CHOOSE_LIST") == 0) {</span>
00551 <span class="comment">    NonR.Skip(1);</span>
00552 <span class="comment">  } else if(strcmp(method, "COMPUTE") == 0) {</span>
00553 <span class="comment">    NonR.Skip(4);</span>
00554 <span class="comment">  } else if(strcmp(method, "SIMPLE_FRAND") == 0) {</span>
00555 <span class="comment">    NonR.Skip(1);</span>
00556 <span class="comment">  }</span>
00557 <span class="comment">  */</span>
00558 }
00559 <span class="comment">//----------------------------------------------------------------------------//</span>
00560 
00561 
00562 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00563"></a><a class="code" href="utility_8cpp.html#a14">00563</a> string <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(<span class="keywordtype">double</span> checkPoint, <span class="keywordtype">int</span> offset) {
00564     cout&lt;&lt;<span class="stringliteral">"ReadComputeChars called, why?"</span>&lt;&lt;endl;
00565     <span class="comment">/*</span>
00566 <span class="comment">  int intValue;</span>
00567 <span class="comment">  float absRange;</span>
00568 <span class="comment">  char * method;</span>
00569 <span class="comment">  string value;</span>
00570 <span class="comment"></span>
00571 <span class="comment">  DataIn rcC; rcC.ReadDummies();</span>
00572 <span class="comment">  rcC.ReadChars(1);</span>
00573 <span class="comment">  method = rcC.nameOf[0];       // which method</span>
00574 <span class="comment"></span>
00575 <span class="comment">  if(strcmp(method, "SEQUENCE") == 0) {</span>
00576 <span class="comment">    value = CharSequence(offset);</span>
00577 <span class="comment">  } else if(strcmp(method, "COMPUTE") == 0) {</span>
00578 <span class="comment">    rcC.ReadInts(1);</span>
00579 <span class="comment">    absRange = rcC.intVect[0];</span>
00580 <span class="comment">    intValue = ValuePick(checkPoint, absRange);</span>
00581 <span class="comment">    value = rcC.nameOf[intValue];</span>
00582 <span class="comment">  } else if(strcmp(method, "SIMPLE_IRAND") == 0) {</span>
00583 <span class="comment">    rcC.ReadInts(2);</span>
00584 <span class="comment">    intValue = RandomNumber(rcC.intVect[0], rcC.intVect[1]);</span>
00585 <span class="comment">    value = rcC.nameOf[intValue];</span>
00586 <span class="comment">  } else {</span>
00587 <span class="comment">    cout &lt;&lt; "Utility::ReadComputeChars - NO method specified" &lt;&lt; endl;</span>
00588 <span class="comment">    cin &gt;&gt; sever;</span>
00589 <span class="comment">  }</span>
00590 <span class="comment"></span>
00591 <span class="comment">  return value;</span>
00592 <span class="comment">  */</span>
00593 }
00594 <span class="comment">//----------------------------------------------------------------------------//</span>
00595 
00596 
00597 <span class="comment">//----------------------------------------------------------------------------//</span>
00598 <span class="comment">/*</span>
00599 <span class="comment">int FrequencyStep(double checkPoint, int newObj, int type, char * keepName) {</span>
00600 <span class="comment">  int absRange, offset, origin, step;</span>
00601 <span class="comment">  char * method;</span>
00602 <span class="comment"></span>
00603 <span class="comment">  DataIn FS; FS.ReadDummies();</span>
00604 <span class="comment"></span>
00605 <span class="comment">  FS.ReadChars(1);</span>
00606 <span class="comment">  method = FS.nameOf[0];</span>
00607 <span class="comment"></span>
00608 <span class="comment">  if(strcmp(method, "SIEVE") == 0) {                // depends on given sieve</span>
00609 <span class="comment">    FS.ReadInts(1);</span>
00610 <span class="comment">    absRange = FS.intVect[0];</span>
00611 <span class="comment">    step = ValuePick(checkPoint, absRange);</span>
00612 <span class="comment">  } else if(strcmp(method, "SELECT") == 0) {        // opens more doors</span>
00613 <span class="comment">    offset = ChooseOffset(newObj, type);</span>
00614 <span class="comment">    step = ReadComputeInt(checkPoint, offset);</span>
00615 <span class="comment">  } else if(strcmp(method, "PAT") == 0) {           // uses a set</span>
00616 <span class="comment">    offset = ChooseOffset(newObj, type);</span>
00617 <span class="comment">    origin = ReadComputeInt(checkPoint, offset);</span>
00618 <span class="comment">    //    cout &lt;&lt; "FrequencyStep - origin=" &lt;&lt; origin &lt;&lt; endl;</span>
00619 <span class="comment"></span>
00620 <span class="comment">    FS.ReadChars(1);</span>
00621 <span class="comment">    char * patFile = FS.nameOf[0];</span>
00622 <span class="comment">    long location = FS.fileLoc();</span>
00623 <span class="comment">    //    cout &lt;&lt; "                        FrequencyStep: " &lt;&lt; patFile &lt;&lt; endl;</span>
00624 <span class="comment">    FS.openFile(patFile);</span>
00625 <span class="comment"></span>
00626 <span class="comment">    Patter pat(patFile);</span>
00627 <span class="comment"></span>
00628 <span class="comment">    if(newObj == 0) {                               // reads from a PAT file</span>
00629 <span class="comment">      pat.Nursery(origin);</span>
00630 <span class="comment">    } else {</span>
00631 <span class="comment">      pat.GetPatty();</span>
00632 <span class="comment">    }</span>
00633 <span class="comment"></span>
00634 <span class="comment">    //    cout &lt;&lt; "                        FrequencyStep: " &lt;&lt; keepName &lt;&lt; endl;</span>
00635 <span class="comment">    FS.openFile(keepName);                          // restore original file</span>
00636 <span class="comment">    FS.rewindFile(location);</span>
00637 <span class="comment"></span>
00638 <span class="comment">    step = pat.Delivery(checkPoint, offset);</span>
00639 <span class="comment">  }</span>
00640 <span class="comment">  return step;</span>
00641 <span class="comment">}</span>
00642 <span class="comment">*/</span>
00643 <span class="comment">//----------------------------------------------------------------------------//</span>
00644 
00645 
00646 <span class="comment">//--------------------------------------------------------------------//</span>
00647 <span class="comment">//                  ENVELOPE-RELATED FUNCTIONS                        //</span>
00648 <span class="comment">//--------------------------------------------------------------------//</span>
00649 
00650 <span class="comment">//--------------------------------------------------------------------//</span>
00651 <span class="comment">/*</span>
00652 <span class="comment">   EnvelopeBuilder</span>
00653 <span class="comment">   </span>
00654 <span class="comment">   This function is used to create envelopes.  There are 4 ways that</span>
00655 <span class="comment">   are currently supported to do this, indicated by the char *method.</span>
00656 <span class="comment"></span>
00657 <span class="comment">   SEG_BUILDER indicates reading in information from a file, and constructing</span>
00658 <span class="comment">   segments by creating a collection of xy coordinates, and then using either linear,</span>
00659 <span class="comment">   exponential, or spline curves to connect them, creating the segments.  These are then passed on</span>
00660 <span class="comment">   to the Envelope function to create the actual envelpoe.</span>
00661 <span class="comment">   </span>
00662 <span class="comment">   SEGS_AND_POINTS indicates that the xy_points and segments have already been calculated, and</span>
00663 <span class="comment">   simply passes these values on to the Envelope constructor.</span>
00664 <span class="comment">   </span>
00665 <span class="comment">   FROM_LIB_FIT indicates loading an envelope from a library and scaling it.</span>
00666 <span class="comment">   </span>
00667 <span class="comment">   FROM_LIB_NUM indicates loading an envelope from a library and using it directly</span>
00668 <span class="comment">   </span>
00669 <span class="comment"></span>
00670 <span class="comment">*/</span>
00671 
<a name="l00672"></a><a class="code" href="utility_8cpp.html#a15">00672</a> Envelope * <a class="code" href="utility_8h.html#a19">EnvelopeBuilder</a>(<span class="keywordtype">char</span> *method, Collection&lt; xy_point &gt; *xy_pts,
00673     Collection&lt; envelope_segment &gt; *segs, <span class="keywordtype">double</span> checkPoint, <span class="keywordtype">int</span> offset,
00674     <span class="keywordtype">double</span> check, <span class="keywordtype">int</span> envNum)
00675 {
00676     <span class="keyword">extern</span> EnvelopeLibrary <a class="code" href="bottom_8cpp.html#a1">envlib</a>;
00677     <span class="keywordtype">int</span> methodNum;
00678     <span class="keywordflow">if</span> (strcmp(method, <span class="stringliteral">"SEG_BUILDER"</span>)) {
00679         methodNum = 1;
00680     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(method, <span class="stringliteral">"SEGS_AND_POINTS"</span>)) {
00681         methodNum = 2;
00682     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(method, <span class="stringliteral">"FROM_LIB_FIT"</span>)) {
00683         methodNum = 3;
00684     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(method, <span class="stringliteral">"FROM_LIB_NUM"</span>)) {
00685         methodNum = 4;
00686     }
00687 
00688     <span class="keywordtype">int</span> numSegs;
00689     <span class="keywordtype">long</span> loc3;
00690     <span class="keywordtype">float</span> previousX = -1.0, previousY = -1.0;
00691     string value;
00692     <span class="keywordtype">char</span> * name;
00693     
00694     Collection&lt; xy_point &gt; xyPointCollection;
00695     xy_point xy;
00696     
00697     Collection&lt; envelope_segment &gt; segmentCollection;
00698     envelope_segment seg;
00699     
00700     <a class="code" href="classDataIn.html">DataIn</a> sb;
00701     
00702     Collection &lt; envelope_segment &gt; segments;
00703     envelope_segment seg2;
00704     xy_point tpt = xy_pts-&gt;get(0);
00705 
00706     <span class="keywordflow">switch</span>(methodNum) {
00707 
00711         <span class="keywordflow">case</span> 1: {
00712 
00713             sb.<a class="code" href="classDataIn.html#a8">GenInts</a>(1);                          <span class="comment">// collection cardinal</span>
00714             
00715             numSegs = sb.<a class="code" href="classDataIn.html#o1">gIntVect</a>[0];
00716             loc3 = sb.<a class="code" href="classDataIn.html#a21">fileLoc</a>();                    <span class="comment">// remember file location</span>
00717 
00718             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numSegs; i++) {
00719                 <span class="keywordflow">if</span>(i != 0) {
00720                     sb.<a class="code" href="classDataIn.html#a20">rewindFile</a>(loc3);            <span class="comment">// back the location</span>
00721                 }
00722 
00723                 xy.x = <a class="code" href="utility_8cpp.html#a12">ReadComputeFloat</a>(check, i);  <span class="comment">// x,y coordinates</span>
00724                 xy.y = <a class="code" href="utility_8cpp.html#a12">ReadComputeFloat</a>(check, i);
00725 
00726                 <span class="comment">// there needs to be a last xy segment - harmless fudge</span>
00727                 <span class="keywordflow">if</span>((i == numSegs - 1) &amp;&amp; (xy.x == previousX)) {
00728                     xy.x *= 1.01;
00729                 }
00730 
00731                 <span class="keywordflow">if</span>(xy.y &lt; 0) {
00732                     xy.y = previousY;               <span class="comment">// assign the same y value</span>
00733                 }
00734 
00735                 xyPointCollection.add(xy);
00736 
00737                 <span class="comment">// last seg has only xy</span>
00738                 <span class="keywordflow">if</span>(i &lt; numSegs - 1) {
00739                     <span class="comment">// get the name (a string)</span>
00740                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i);
00741                     name = (<span class="keywordtype">char</span> *) value.data();
00742 
00743                     <span class="comment">// check the interpolator types</span>
00744                     <span class="keywordflow">if</span>(strcmp(name, <span class="stringliteral">"LINEAR"</span>) == 0) {
00745                         seg.interType = LINEAR;
00746                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( strcmp(name, <span class="stringliteral">"EXPONENTIAL"</span>) == 0) {
00747                         seg.interType = EXPONENTIAL;
00748                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( strcmp(name, <span class="stringliteral">"CUBIC_SPLINE"</span>) == 0) {
00749                         seg.interType = CUBIC_SPLINE;
00750                     }
00751 
00752                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(i == numSegs - 1) {       <span class="comment">// last seg read previous</span>
00753                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i-1);
00754                 }
00755 
00756                 <span class="keywordflow">if</span>(i &lt; numSegs - 1) {               <span class="comment">// same for length types</span>
00757                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i);
00758                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(i == numSegs - 1) {       <span class="comment">// last seg read previous</span>
00759                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i-1);
00760                 }
00761 
00762                 <span class="keywordflow">if</span>(i &lt; numSegs - 1) {               <span class="comment">// same for length types</span>
00763                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i);
00764                     name = (<span class="keywordtype">char</span> *) value.data();
00765 
00766                     <span class="keywordflow">if</span>(strcmp(name, <span class="stringliteral">"FIXED"</span>) == 0) {
00767                         seg.lengthType = FIXED;
00768                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(name, <span class="stringliteral">"FLEXIBLE"</span>) == 0) {
00769                         seg.lengthType = FLEXIBLE;
00770                     }
00771                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(i == numSegs - 1) {       <span class="comment">// last seg read previous</span>
00772                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i-1);
00773                 }
00774 
00775                 <span class="keywordflow">if</span>(xy.x &gt; previousX) {
00776                     segmentCollection.add(seg);
00777                 }
00778 
00779                 previousX = xy.x;                   <span class="comment">// remember these values</span>
00780                 previousY = xy.y;
00781             }
00782 
00783             <span class="comment">// we've built the segments now, so simply call the envelope</span>
00784             <span class="comment">// constructor which builds the envelope via points and</span>
00785             <span class="comment">// segments</span>
00786             Envelope * newEnv = <span class="keyword">new</span> Envelope(xyPointCollection, segmentCollection);
00787 
00788             xyPointCollection.clear();
00789             segmentCollection.clear();
00790 
00791             <span class="keywordflow">return</span> newEnv;
00792 
00793             <span class="keywordflow">break</span>;
00794         }
00795 
00799         <span class="keywordflow">case</span> 2: {
00800             
00801             <span class="comment">// just simply pass along the values here</span>
00802             Envelope * newEnv2 = <span class="keyword">new</span> Envelope(*xy_pts, *segs);
00803 
00804             <span class="keywordflow">return</span> newEnv2;
00805 
00806             <span class="keywordflow">break</span>;
00807         }
00808 
00812         <span class="keywordflow">case</span> 3: {
00813             Envelope * newEnv3 = <a class="code" href="bottom_8cpp.html#a1">envlib</a>.getEnvelope(<a class="code" href="utility_8cpp.html#a11">ReadComputeInt</a>(checkPoint, offset));
00814             newEnv3-&gt;scale(<a class="code" href="utility_8cpp.html#a12">ReadComputeFloat</a>(checkPoint, offset));
00815         
00816             <span class="keywordflow">return</span> newEnv3;
00817 
00818             <span class="keywordflow">break</span>;
00819         }
00820 
00821         <span class="keywordflow">case</span> 4: {
00822             Envelope * newEnv4 = <a class="code" href="bottom_8cpp.html#a1">envlib</a>.getEnvelope(envNum);
00823 
00824             <span class="keywordflow">return</span> newEnv4;
00825 
00826             <span class="keywordflow">break</span>;
00827         }
00828 
00829         <span class="keywordflow">default</span>: {  <span class="comment">// the method wasn't recognized </span>
00830             cout &lt;&lt; <span class="stringliteral">"Utility::EnvelopeBuilder  ERROR: "</span>;
00831             cout &lt;&lt; <span class="stringliteral">"Not a recognized method! "</span>;
00832             cout &lt;&lt; <span class="stringliteral">"method: "</span> &lt;&lt; method &lt;&lt; endl;
00833             <span class="keywordflow">break</span>;
00834         }
00835     }
00836 }
00837 <span class="comment">//----------------------------------------------------------------------------//</span>
00838 
00839 <span class="comment">//--------------------------------------------------------------------//</span>
00840 <span class="comment">/*</span>
00841 <span class="comment">   EnvelopeBuilder</span>
00842 <span class="comment">   </span>
00843 <span class="comment">   This function is used to create envelopes.  There are 4 ways that</span>
00844 <span class="comment">   are currently supported to do this, indicated by the char *method.</span>
00845 <span class="comment"></span>
00846 <span class="comment">   SEG_BUILDER indicates reading in information from a file, and constructing</span>
00847 <span class="comment">   segments by creating a collection of xy coordinates, and then using either linear,</span>
00848 <span class="comment">   exponential, or spline curves to connect them, creating the segments.  These are then passed on</span>
00849 <span class="comment">   to the Envelope function to create the actual envelpoe.</span>
00850 <span class="comment">   </span>
00851 <span class="comment">   SEGS_AND_POINTS indicates that the xy_points and segments have already been calculated, and</span>
00852 <span class="comment">   simply passes these values on to the Envelope constructor.</span>
00853 <span class="comment">   </span>
00854 <span class="comment">   FROM_LIB_FIT indicates loading an envelope from a library and scaling it.</span>
00855 <span class="comment">   </span>
00856 <span class="comment">   FROM_LIB_NUM indicates loading an envelope from a library and using it directly</span>
00857 <span class="comment">   </span>
00858 <span class="comment"></span>
00859 <span class="comment">*/</span>
<a name="l00860"></a><a class="code" href="utility_8cpp.html#a16">00860</a> Envelope * <a class="code" href="utility_8h.html#a19">EnvelopeBuilder</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *method, Collection&lt; xy_point &gt; *xy_pts,
00861     Collection&lt; envelope_segment &gt; *segs, <span class="keywordtype">double</span> checkPoint, <span class="keywordtype">int</span> offset,
00862     <span class="keywordtype">double</span> check, <span class="keywordtype">int</span> envNum, <span class="keywordtype">int</span> numSegs)
00863 {
00864     <span class="keyword">extern</span> EnvelopeLibrary <a class="code" href="bottom_8cpp.html#a1">envlib</a>;
00865     <span class="keywordtype">int</span> methodNum;
00866     <span class="keywordflow">if</span> (strcmp(method, <span class="stringliteral">"SEG_BUILDER"</span>)) {
00867         methodNum = 1;
00868     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(method, <span class="stringliteral">"SEGS_AND_POINTS"</span>)) {
00869         methodNum = 2;
00870     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(method, <span class="stringliteral">"FROM_LIB_FIT"</span>)) {
00871         methodNum = 3;
00872     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(method, <span class="stringliteral">"FROM_LIB_NUM"</span>)) {
00873         methodNum = 4;
00874     }
00875 
00876     <span class="keywordtype">float</span> previousX = -1.0, previousY = -1.0;
00877     string value;
00878     <span class="keywordtype">char</span> * name;
00879     
00880     Collection&lt; xy_point &gt; xyPointCollection;
00881     xy_point xy;
00882     
00883     Collection&lt; envelope_segment &gt; segmentCollection;
00884     envelope_segment seg;
00885     
00886     Collection &lt; envelope_segment &gt; segments;
00887     envelope_segment seg2;
00888     xy_point tpt = xy_pts-&gt;get(0);
00889 
00890     <span class="keywordflow">switch</span>(methodNum) {
00891 
00895         <span class="keywordflow">case</span> 1: {
00896 
00897             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numSegs; i++) {
00898 
00899                 xy.x = <a class="code" href="utility_8cpp.html#a12">ReadComputeFloat</a>(check, i);  <span class="comment">// x,y coordinates</span>
00900                 xy.y = <a class="code" href="utility_8cpp.html#a12">ReadComputeFloat</a>(check, i);
00901 
00902                 <span class="comment">// there needs to be a last xy segment - harmless fudge</span>
00903                 <span class="keywordflow">if</span>((i == numSegs - 1) &amp;&amp; (xy.x == previousX)) {
00904                     xy.x *= 1.01;
00905                 }
00906 
00907                 <span class="keywordflow">if</span>(xy.y &lt; 0) {
00908                     xy.y = previousY;               <span class="comment">// assign the same y value</span>
00909                 }
00910 
00911                 xyPointCollection.add(xy);
00912 
00913                 <span class="comment">// last seg has only xy</span>
00914                 <span class="keywordflow">if</span>(i &lt; numSegs - 1) {
00915                     <span class="comment">// get the name (a string)</span>
00916                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i);
00917                     name = (<span class="keywordtype">char</span> *) value.data();
00918 
00919                     <span class="comment">// check the interpolator types</span>
00920                     <span class="keywordflow">if</span>(strcmp(name, <span class="stringliteral">"LINEAR"</span>) == 0) {
00921                         seg.interType = LINEAR;
00922                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( strcmp(name, <span class="stringliteral">"EXPONENTIAL"</span>) == 0) {
00923                         seg.interType = EXPONENTIAL;
00924                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( strcmp(name, <span class="stringliteral">"CUBIC_SPLINE"</span>) == 0) {
00925                         seg.interType = CUBIC_SPLINE;
00926                     }
00927 
00928                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(i == numSegs - 1) {       <span class="comment">// last seg read previous</span>
00929                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i-1);
00930                 }
00931 
00932                 <span class="keywordflow">if</span>(i &lt; numSegs - 1) {               <span class="comment">// same for length types</span>
00933                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i);
00934                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(i == numSegs - 1) {       <span class="comment">// last seg read previous</span>
00935                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i-1);
00936                 }
00937 
00938                 <span class="keywordflow">if</span>(i &lt; numSegs - 1) {               <span class="comment">// same for length types</span>
00939                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i);
00940                     name = (<span class="keywordtype">char</span> *) value.data();
00941 
00942                     <span class="keywordflow">if</span>(strcmp(name, <span class="stringliteral">"FIXED"</span>) == 0) {
00943                         seg.lengthType = FIXED;
00944                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(name, <span class="stringliteral">"FLEXIBLE"</span>) == 0) {
00945                         seg.lengthType = FLEXIBLE;
00946                     }
00947                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(i == numSegs - 1) {       <span class="comment">// last seg read previous</span>
00948                     value = <a class="code" href="utility_8cpp.html#a14">ReadComputeChars</a>(check, i-1);
00949                 }
00950 
00951                 <span class="keywordflow">if</span>(xy.x &gt; previousX) {
00952                     segmentCollection.add(seg);
00953                 }
00954 
00955                 previousX = xy.x;                   <span class="comment">// remember these values</span>
00956                 previousY = xy.y;
00957             }
00958 
00959             <span class="comment">// we've built the segments now, so simply call the envelope</span>
00960             <span class="comment">// constructor which builds the envelope via points and</span>
00961             <span class="comment">// segments</span>
00962             Envelope * newEnv = <span class="keyword">new</span> Envelope(xyPointCollection, segmentCollection);
00963 
00964             xyPointCollection.clear();
00965             segmentCollection.clear();
00966 
00967             <span class="keywordflow">return</span> newEnv;
00968 
00969             <span class="keywordflow">break</span>;
00970         }
00971 
00975         <span class="keywordflow">case</span> 2: {
00976             
00977             <span class="comment">// just simply pass along the values here</span>
00978             Envelope * newEnv2 = <span class="keyword">new</span> Envelope(*xy_pts, *segs);
00979 
00980             <span class="keywordflow">return</span> newEnv2;
00981 
00982             <span class="keywordflow">break</span>;
00983         }
00984 
00988         <span class="keywordflow">case</span> 3: {
00989             Envelope * newEnv3 = <a class="code" href="bottom_8cpp.html#a1">envlib</a>.getEnvelope(<a class="code" href="utility_8cpp.html#a11">ReadComputeInt</a>(checkPoint, offset));
00990             newEnv3-&gt;scale(<a class="code" href="utility_8cpp.html#a12">ReadComputeFloat</a>(checkPoint, offset));
00991         
00992             <span class="keywordflow">return</span> newEnv3;
00993 
00994             <span class="keywordflow">break</span>;
00995         }
00996 
00997         <span class="keywordflow">case</span> 4: {
00998             Envelope * newEnv4 = <a class="code" href="bottom_8cpp.html#a1">envlib</a>.getEnvelope(envNum);
00999 
01000             <span class="keywordflow">return</span> newEnv4;
01001 
01002             <span class="keywordflow">break</span>;
01003         }
01004 
01005         <span class="keywordflow">default</span>: {  <span class="comment">// the method wasn't recognized </span>
01006             cout &lt;&lt; <span class="stringliteral">"Utility::EnvelopeBuilder  ERROR: "</span>;
01007             cout &lt;&lt; <span class="stringliteral">"Not a recognized method! "</span>;
01008             cout &lt;&lt; <span class="stringliteral">"method: "</span> &lt;&lt; method &lt;&lt; endl;
01009             <span class="keywordflow">break</span>;
01010         }
01011     }
01012 }
01013 <span class="comment">//----------------------------------------------------------------------------//</span>
01014 
01015 
01016 <span class="comment">//----------------------------------------------------------------------------//</span>
01017 <span class="comment">/*</span>
01018 <span class="comment">  envValue</span>
01019 <span class="comment">  </span>
01020 <span class="comment">  This function takes in an int envNum, indicating which of the envelopes from the</span>
01021 <span class="comment">  envelope library is to be used, and coef, a scalar factor for the envelope.  The</span>
01022 <span class="comment">  value of the envelope at point checkPoint is then returned.</span>
01023 <span class="comment">*/</span>
<a name="l01024"></a><a class="code" href="utility_8cpp.html#a17">01024</a> <span class="keywordtype">float</span> <a class="code" href="utility_8cpp.html#a17">envValue</a> (<span class="keywordtype">double</span> checkPoint, <span class="keywordtype">int</span> envNum, <span class="keywordtype">float</span> coef) {
01025   <span class="keywordtype">float</span> value;
01026   <span class="keyword">extern</span> EnvelopeLibrary <a class="code" href="bottom_8cpp.html#a1">envlib</a>;
01027 
01028   <span class="comment">// create an Envelope</span>
01029   Envelope *env;
01030     
01031   <span class="comment">//get an envelope from the library and scale it</span>
01032   env = <a class="code" href="bottom_8cpp.html#a1">envlib</a>.getEnvelope(envNum);
01033   env-&gt;scale(coef);
01034 
01035   <span class="comment">/* cout &lt;&lt; "Utility::envValue envelope " &lt;&lt; envNum &lt;&lt; endl;</span>
01036 <span class="comment">     env-&gt;Print(); */</span>
01037 
01038   <span class="comment">// Find the envelope value</span>
01039   value = env-&gt;getValue(checkPoint, 1.);
01040 
01041   <span class="comment">/* cout &lt;&lt; "Utility::envValue - checkPoint=" &lt;&lt; checkPoint &lt;&lt; " value=" &lt;&lt; </span>
01042 <span class="comment">     value &lt;&lt; endl;*/</span>
01043 
01044   <span class="keywordflow">return</span> value;
01045 }
01046 <span class="comment">//----------------------------------------------------------------------------//</span>
01047 
01048 
01049 <span class="comment">//----------------------------------------------------------------------------//</span>
01050 <span class="comment">/*</span>
01051 <span class="comment">  FitEnvelope</span>
01052 <span class="comment">  </span>
01053 <span class="comment">  This function relies on deprecated functions, and should not currently be used.</span>
01054 <span class="comment">*/</span>
01055 
01056 <span class="comment">/*</span>
01057 <span class="comment">Envelope * FitEnvelope(double checkPoint, int offset) {</span>
01058 <span class="comment">  int envNum;</span>
01059 <span class="comment">  float coeff;</span>
01060 <span class="comment">  extern EnvelopeLibrary envlib;</span>
01061 <span class="comment"></span>
01062 <span class="comment">  Envelope * env;</span>
01063 <span class="comment"></span>
01064 <span class="comment">  envNum = ReadComputeInt(checkPoint, offset);</span>
01065 <span class="comment">  coeff = ReadComputeFloat(checkPoint, offset);</span>
01066 <span class="comment">  env = envlib.getEnvelope(envNum);</span>
01067 <span class="comment">  env-&gt;scale(coeff);</span>
01068 <span class="comment"></span>
01069 <span class="comment">  // cout &lt;&lt; "Utility::FitEnvelope  - envNum=" &lt;&lt; envNum &lt;&lt; " coeff=" &lt;&lt; coeff </span>
01070 <span class="comment">   //  &lt;&lt; " scaled" &lt;&lt; endl;</span>
01071 <span class="comment">  </span>
01072 <span class="comment"></span>
01073 <span class="comment">  return env;</span>
01074 <span class="comment">}</span>
01075 <span class="comment">*/</span>
01076 
01077 <span class="comment">//----------------------------------------------------------------------------//</span>
01078 
01079 
01080 <span class="comment">//----------------------------------------------------------------------------//</span>
01081 <span class="comment">/* </span>
01082 <span class="comment">   SelectEnvType</span>
01083 <span class="comment">   </span>
01084 <span class="comment">   This function relies on deprecated functions and should be updated or removed.</span>
01085 <span class="comment">*/</span>
01086 <span class="comment">/*</span>
01087 <span class="comment">Envelope * SelectEnvType(double checkPoint, int newObj, int type, double check,</span>
01088 <span class="comment"> int offset, char * fileName) {</span>
01089 <span class="comment">  int envItems;</span>
01090 <span class="comment">  long loc4;</span>
01091 <span class="comment">  char * envFile;</span>
01092 <span class="comment"></span>
01093 <span class="comment">  Envelope * env; Envelope * env2;          // create 2 envelopes</span>
01094 <span class="comment"></span>
01095 <span class="comment">  DataIn Set; </span>
01096 <span class="comment"></span>
01097 <span class="comment">  Set.ReadInts(1); </span>
01098 <span class="comment">  envItems = Set.intVect[0];                // how many envelopes ?</span>
01099 <span class="comment"></span>
01100 <span class="comment">  for(int j = 0; j &lt; envItems; j++) {</span>
01101 <span class="comment">    Set.ReadDummies();                      // old or new envelope</span>
01102 <span class="comment">    if(strcmp(Set.cAr, "OLD") == 0) {       // from library</span>
01103 <span class="comment">      //ENVELOPE FUNCTION USED HERE </span>
01104 <span class="comment">      env = FitEnvelope(checkPoint, offset);    // utility (envNum, scale)</span>
01105 <span class="comment">    } else if(strcmp(Set.cAr, "MAKE") == 0) {   // make one on-the-fly</span>
01106 <span class="comment">      Set.ReadChars(1);</span>
01107 <span class="comment">      envFile = Set.nameOf[0];                  // ENV file to use</span>
01108 <span class="comment">      loc4 = Set.fixleLoc();                        // loc current file</span>
01109 <span class="comment">      cout &lt;&lt; "                    Utility::SelectEnvType: " &lt;&lt; envFile &lt;&lt; endl;</span>
01110 <span class="comment">      Set.openFile(envFile);                    // open ENV file</span>
01111 <span class="comment">      Set.rewindFile(0);</span>
01112 <span class="comment">      //ENVELOPE FUNCTION USED HERE </span>
01113 <span class="comment">      env = MakeEnvelope(checkPoint, offset, check);</span>
01114 <span class="comment">      cout &lt;&lt; "                    Utility::SelectEnvType: " &lt;&lt; fileName &lt;&lt; endl;</span>
01115 <span class="comment">      Set.openFile(fileName); Set.rewindFile(loc4); // restore old file</span>
01116 <span class="comment">    } else {</span>
01117 <span class="comment">      cout &lt;&lt; "SelectEnvType - NO method available" &lt;&lt; endl;</span>
01118 <span class="comment">      cin &gt;&gt; sever;</span>
01119 <span class="comment">    }</span>
01120 <span class="comment"></span>
01121 <span class="comment">    if(j &gt; 0) env = env2-&gt;multiply(* env, * env2);  // multiply 2 envelopes</span>
01122 <span class="comment">  </span>
01123 <span class="comment">    if(envItems &gt; 1) env2 = env;                    // copy envelope</span>
01124 <span class="comment">  }</span>
01125 <span class="comment"></span>
01126 <span class="comment">  return env;</span>
01127 <span class="comment">}</span>
01128 <span class="comment">*/</span>
01129 <span class="comment">//----------------------------------------------------------------------------//</span>
01130 
01131 
01132 <span class="comment">//----------------------------------------------------------------------------//</span>
01133 <span class="comment">/*</span>
01134 <span class="comment">  MakeEnvelope</span>
01135 <span class="comment">  </span>
01136 <span class="comment">  This function relies on deprecated functions, and should not currently be used.</span>
01137 <span class="comment">*/</span>
01138 
01139 <span class="comment">/*</span>
01140 <span class="comment">Envelope * MakeEnvelope(double checkPoint, int offset, double check) {</span>
01141 <span class="comment">  float coeff;</span>
01142 <span class="comment">  char * method;</span>
01143 <span class="comment"></span>
01144 <span class="comment">  Envelope * env;</span>
01145 <span class="comment"></span>
01146 <span class="comment">  DataIn me; me.ReadDummies();</span>
01147 <span class="comment">  me.ReadChars(1);</span>
01148 <span class="comment">  method = me.nameOf[0];</span>
01149 <span class="comment"></span>
01150 <span class="comment">  if(strcmp(method, "SEG_BUILDER") == 0) {</span>
01151 <span class="comment">      /* ENVELOPE FUNCTION USED HERE </span>
01152 <span class="comment">    env = SegmentBuilder(check);</span>
01153 <span class="comment">  } else if(strcmp(method, "ARRIVAL_POINT") == 0) {</span>
01154 <span class="comment">    cout &lt;&lt; "ArrivalPoint not available yet" &lt;&lt; endl;</span>
01155 <span class="comment">  } else if(strcmp(method, "FAMILY") == 0) {</span>
01156 <span class="comment">    cout &lt;&lt; "EnvelopeFamily not available yet" &lt;&lt; endl;</span>
01157 <span class="comment">  } else {</span>
01158 <span class="comment">    cout &lt;&lt; "Envelope * MakeEnvelope - no method available; method: " &lt;&lt; method</span>
01159 <span class="comment">      &lt;&lt; endl;</span>
01160 <span class="comment">    cin &gt;&gt; sever;</span>
01161 <span class="comment">  }</span>
01162 <span class="comment"></span>
01163 <span class="comment">  coeff = ReadComputeFloat(checkPoint, offset);</span>
01164 <span class="comment">  env-&gt;scale(coeff);</span>
01165 <span class="comment"></span>
01166 <span class="comment">// cout &lt;&lt; "MakeEnvelope  - coeff=" &lt;&lt; coeff &lt;&lt; "  env:" &lt;&lt; endl;</span>
01167 <span class="comment">//   env-&gt;Print();</span>
01168 <span class="comment">//   cin &gt;&gt; sever; </span>
01169 <span class="comment"></span>
01170 <span class="comment">  return env;</span>
01171 <span class="comment">}</span>
01172 <span class="comment">*/</span>
01173 <span class="comment">//----------------------------------------------------------------------------//</span>
01174 
01175 
01176 <span class="comment">//----------------------------------------------------------------------------//</span>
01177 <span class="comment">/*</span>
01178 <span class="comment">  SegmentBuilder</span>
01179 <span class="comment"></span>
01180 <span class="comment">  This function relies on deprecated functions, and should not currently be used.</span>
01181 <span class="comment">*/</span>
01182 
01183 <span class="comment">/*</span>
01184 <span class="comment">Envelope * SegmentBuilder(double check) { </span>
01185 <span class="comment">  int numSegs;</span>
01186 <span class="comment">  long loc3;</span>
01187 <span class="comment">  float previousX = -1.0, previousY = -1.0;</span>
01188 <span class="comment">  string value;</span>
01189 <span class="comment">  char * name;</span>
01190 <span class="comment"></span>
01191 <span class="comment">  Collection&lt;xy_point&gt; xyPointCollection;           // Make a collection</span>
01192 <span class="comment">  xy_point xy;</span>
01193 <span class="comment">  Collection&lt;envelope_segment&gt; segmentCollection;   // Make another collection</span>
01194 <span class="comment">  envelope_segment seg;</span>
01195 <span class="comment"></span>
01196 <span class="comment">  DataIn sb; sb.GenInts(1);                         // collection cardinal</span>
01197 <span class="comment">  numSegs = sb.gIntVect[0];</span>
01198 <span class="comment">  loc3 = sb.fileLoc();                              // remember file location</span>
01199 <span class="comment"></span>
01200 <span class="comment">  for(int i = 0; i &lt; numSegs; i++) {</span>
01201 <span class="comment">    if(i != 0) sb.rewindFile(loc3);                 // back to that location</span>
01202 <span class="comment"></span>
01203 <span class="comment">    xy.x = ReadComputeFloat(check, i);              // x,y coordinates</span>
01204 <span class="comment">    xy.y = ReadComputeFloat(check, i);</span>
01205 <span class="comment"></span>
01206 <span class="comment">    //there needs to be a last xy segment - harmless fudge</span>
01207 <span class="comment">    if(i == numSegs - 1 &amp;&amp; xy.x == previousX) xy.x *= 1.01;</span>
01208 <span class="comment">    if(xy.y &lt; 0) xy.y = previousY;                  // assign the same y value</span>
01209 <span class="comment">    xyPointCollection.add(xy);</span>
01210 <span class="comment"></span>
01211 <span class="comment">    if(i &lt; numSegs - 1) {                           // last seg has only xy</span>
01212 <span class="comment">      value = ReadComputeChars(check, i);           // get the name (a string)</span>
01213 <span class="comment">      name = (char *) value.data();</span>
01214 <span class="comment"></span>
01215 <span class="comment">      if(strcmp(name, "LINEAR") == 0) {             // interpolator types</span>
01216 <span class="comment">        seg.interType = LINEAR;</span>
01217 <span class="comment">      } else if( strcmp(name, "EXPONENTIAL") == 0) {</span>
01218 <span class="comment">        seg.interType = EXPONENTIAL;</span>
01219 <span class="comment">      } else if( strcmp(name, "CUBIC_SPLINE") == 0) {</span>
01220 <span class="comment">        seg.interType = CUBIC_SPLINE;</span>
01221 <span class="comment">      }</span>
01222 <span class="comment">    } else if(i == numSegs - 1) {                   // last seg read previous</span>
01223 <span class="comment">      value = ReadComputeChars(check, i-1);</span>
01224 <span class="comment">    }</span>
01225 <span class="comment"></span>
01226 <span class="comment">    if(i &lt; numSegs - 1) {                           // same for length types</span>
01227 <span class="comment">      value = ReadComputeChars(check, i);</span>
01228 <span class="comment">      name = (char *) value.data();</span>
01229 <span class="comment"></span>
01230 <span class="comment">      if(strcmp(name, "FIXED") == 0) {</span>
01231 <span class="comment">        seg.lengthType = FIXED;</span>
01232 <span class="comment">      } else if(strcmp(name, "FLEXIBLE") == 0) {</span>
01233 <span class="comment">        seg.lengthType = FLEXIBLE;</span>
01234 <span class="comment">      }</span>
01235 <span class="comment">    } else if(i == numSegs - 1) {                   // last seg read previous</span>
01236 <span class="comment">      value = ReadComputeChars(check, i-1);</span>
01237 <span class="comment">    }</span>
01238 <span class="comment"></span>
01239 <span class="comment">    if(xy.x &gt; previousX) {</span>
01240 <span class="comment">      segmentCollection.add(seg);</span>
01241 <span class="comment">    }         </span>
01242 <span class="comment">    previousX = xy.x;                               // remember these values</span>
01243 <span class="comment">    previousY = xy.y;</span>
01244 <span class="comment">  }</span>
01245 <span class="comment"></span>
01246 <span class="comment">  Envelope * env = new Envelope(xyPointCollection, segmentCollection);</span>
01247 <span class="comment">  xyPointCollection.clear(); segmentCollection.clear();</span>
01248 <span class="comment"></span>
01249 <span class="comment">  return env;</span>
01250 <span class="comment">}</span>
01251 <span class="comment">*/</span>
01252 <span class="comment">//----------------------------------------------------------------------------//</span>
01253 
01254 
01255 <span class="comment">//--------------------------------------------------------------------//</span>
01256 <span class="comment">//                  END ENVELOPE-RELATED FUNCTIONS                    //</span>
01257 <span class="comment">//--------------------------------------------------------------------//</span>
01258 
01259 
01260 <span class="comment">//----------------------------------------------------------------------------//</span>
01261 <span class="comment">/*</span>
01262 <span class="comment">  NonEnv</span>
01263 <span class="comment">  </span>
01264 <span class="comment">  This method puts the cursor of the currently open file to the correct position after</span>
01265 <span class="comment">  reading an envelope's information.</span>
01266 <span class="comment">*/</span>
01267 <span class="comment">/*</span>
01268 <span class="comment">void NonEnv() {</span>
01269 <span class="comment">  char * method;</span>
01270 <span class="comment">  </span>
01271 <span class="comment">  DataIn NonSet;</span>
01272 <span class="comment">  </span>
01273 <span class="comment">  NonSet.ReadChars(1);          // offset</span>
01274 <span class="comment">  NonSet.ReadInts(1);           // how many envelopes</span>
01275 <span class="comment">  NonSet.ReadDummies();         // old or new envelope</span>
01276 <span class="comment">  </span>
01277 <span class="comment">  if(strcmp(NonSet.cAr, "OLD") == 0) {</span>
01278 <span class="comment">    NonSet.Skip(6);             // skip 6 lines</span>
01279 <span class="comment">  } else if(strcmp(NonSet.cAr, "MAKE") == 0) {</span>
01280 <span class="comment">    NonSet.Skip(1);             // skip 1 line</span>
01281 <span class="comment">  }</span>
01282 <span class="comment">}</span>
01283 <span class="comment">*/</span>
01284 <span class="comment">//----------------------------------------------------------------------------//</span>
01285 
01286 
01287 <span class="comment">//----------------------------------------------------------------------------//</span>
01288 <span class="comment">/*</span>
01289 <span class="comment">  ChooseOffset</span>
01290 <span class="comment">  </span>
01291 <span class="comment">  This function uses the values passed in in conjunction with the current information</span>
01292 <span class="comment">  being read in from the open file to select an offset to return.</span>
01293 <span class="comment">*/</span>
01294 
<a name="l01295"></a><a class="code" href="utility_8cpp.html#a18">01295</a> <span class="keywordtype">int</span> <a class="code" href="utility_8cpp.html#a18">ChooseOffset</a>(<span class="keywordtype">int</span> first, <span class="keywordtype">int</span> second) {
01296   cout&lt;&lt;<span class="stringliteral">"ChooseOffest(int, int) was called.  Why are we still using deprecated functions?"</span>;
01297   <span class="comment">/*</span>
01298 <span class="comment">  int offset;</span>
01299 <span class="comment">  DataIn Co; Co.ReadChars(1);</span>
01300 <span class="comment"></span>
01301 <span class="comment">  if(strcmp(Co.nameOf[0], "OBJNUM") == 0) {</span>
01302 <span class="comment">    offset = first;</span>
01303 <span class="comment">  } else if(strcmp(Co.nameOf[0], "TYPE") == 0) {</span>
01304 <span class="comment">    offset = second;</span>
01305 <span class="comment">  } else if(strcmp(Co.nameOf[0], "ZERO") == 0) {</span>
01306 <span class="comment">    offset = 0;</span>
01307 <span class="comment">  } else {</span>
01308 <span class="comment">    cout &lt;&lt; "ChooseOffset - can not choose offset " &lt;&lt; Co.dummy &lt;&lt; " " &lt;&lt;</span>
01309 <span class="comment">      Co.nameOf[0] &lt;&lt;  endl;</span>
01310 <span class="comment">    cin &gt;&gt; sever;</span>
01311 <span class="comment">  }</span>
01312 <span class="comment"></span>
01313 <span class="comment">  if(offset &lt; 0) {</span>
01314 <span class="comment">    cout &lt;&lt; "ChooseOffset - wrong offset = " &lt;&lt; offset &lt;&lt; endl;</span>
01315 <span class="comment">    cin &gt;&gt; sever;</span>
01316 <span class="comment">  }</span>
01317 <span class="comment">  */</span>
01318   <span class="keywordflow">return</span> -1;
01319 }
01320 
01321 <span class="comment">//----------------------------------------------------------------------------//</span>
01322 
01323 
01324 <span class="comment">//----------------------------------------------------------------------------//</span>
01325 <span class="comment">/*</span>
01326 <span class="comment">  Sequence</span>
01327 <span class="comment">  </span>
01328 <span class="comment"></span>
01329 <span class="comment">*/</span>
<a name="l01330"></a><a class="code" href="utility_8cpp.html#a19">01330</a> <span class="keywordtype">float</span> <a class="code" href="utility_8cpp.html#a19">Sequence</a>(<span class="keywordtype">int</span> offset) {
01331   <span class="keywordtype">int</span> cardinal, element;
01332 
01333   <a class="code" href="classDataIn.html">DataIn</a> seq;
01334   seq.<a class="code" href="classDataIn.html#a11">ReadInts</a>(1);              <span class="comment">// how many in the sequence ?</span>
01335   cardinal = seq.<a class="code" href="classDataIn.html#o0">intVect</a>[0];
01336   seq.<a class="code" href="classDataIn.html#a9">GenFloats</a>(cardinal);
01337 
01338   <span class="keywordflow">if</span>(offset &gt;= cardinal) {
01339     element = offset % cardinal;
01340   } <span class="keywordflow">else</span> {
01341     element = offset;
01342   }
01343 
01344   <span class="keywordflow">return</span> seq.<a class="code" href="classDataIn.html#o3">gFloatVect</a>[element];
01345 }       
01346 <span class="comment">//----------------------------------------------------------------------------//</span>
01347 
01348 
01349 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l01350"></a><a class="code" href="utility_8cpp.html#a20">01350</a> string <a class="code" href="utility_8cpp.html#a20">CharSequence</a>(<span class="keywordtype">int</span> offset) {
01351   <span class="keywordtype">int</span> cardinal;
01352   string value;
01353 
01354   <a class="code" href="classDataIn.html">DataIn</a> Cs;
01355   Cs.<a class="code" href="classDataIn.html#a11">ReadInts</a>(1);
01356   cardinal = Cs.<a class="code" href="classDataIn.html#o0">intVect</a>[0];
01357   Cs.<a class="code" href="classDataIn.html#a10">GenChars</a>(cardinal);
01358 
01359   <span class="keywordflow">return</span> value = Cs.<a class="code" href="classDataIn.html#o16">nameOf</a>[offset];
01360 }       
01361 <span class="comment">//----------------------------------------------------------------------------//</span>
01362 
01363 
01364 <span class="comment">//----------------------------------------------------------------------------//</span>
01365 <span class="comment">/*</span>
01366 <span class="comment">  SoundsPerSec</span>
01367 <span class="comment">  </span>
01368 <span class="comment">  This function calculates the sounds per second by reading information from the current </span>
01369 <span class="comment">  state of the file, and scaling by the density that is passed in.</span>
01370 <span class="comment">*/</span>
01371 
<a name="l01372"></a><a class="code" href="utility_8cpp.html#a21">01372</a> <span class="keywordtype">float</span> <a class="code" href="utility_8cpp.html#a22">SoundsPerSec</a>(<span class="keywordtype">float</span> dens) {
01373   cout&lt;&lt;<span class="stringliteral">"Deprecated function SoundsPerSec(float) called. Why?"</span>;
01374   <span class="comment">/*</span>
01375 <span class="comment"></span>
01376 <span class="comment">  int areas, underOne;</span>
01377 <span class="comment">  float soundsPsec;</span>
01378 <span class="comment"></span>
01379 <span class="comment">  DataIn sPs; sPs.ReadDummies();</span>
01380 <span class="comment">  sPs.ReadInts(2);</span>
01381 <span class="comment">  areas = sPs.intVect[0];</span>
01382 <span class="comment">  underOne = sPs.intVect[1];</span>
01383 <span class="comment"></span>
01384 <span class="comment">  soundsPsec = pow(2, dens * areas - underOne);</span>
01385 <span class="comment"></span>
01386 <span class="comment">  // cout &lt;&lt; "SoundPerSec - dens=" &lt;&lt; dens &lt;&lt; " areas=" &lt;&lt; areas &lt;&lt; " underOne="</span>
01387 <span class="comment">  // &lt;&lt; underOne &lt;&lt; " soundsPsec=" &lt;&lt; soundsPsec &lt;&lt; endl;</span>
01388 <span class="comment"></span>
01389 <span class="comment">  */</span>
01390   <span class="keywordflow">return</span> -1.0;
01391 
01392 }
01393 
01394 
01395 <span class="comment">/*</span>
01396 <span class="comment">  SoundsPerSec</span>
01397 <span class="comment"></span>
01398 <span class="comment">  This function calculates the number of sounds per second, given the density, number of areas, </span>
01399 <span class="comment">  and sentinal value.</span>
01400 <span class="comment">*/</span>
<a name="l01401"></a><a class="code" href="utility_8cpp.html#a22">01401</a> <span class="keywordtype">float</span> <a class="code" href="utility_8cpp.html#a22">SoundsPerSec</a>(<span class="keywordtype">float</span> dens, <span class="keywordtype">int</span> areas, <span class="keywordtype">int</span> underOne) {
01402   <span class="keywordtype">float</span> soundsPsec;
01403 
01404    soundsPsec = pow(2, dens * areas - underOne);
01405 
01406   <span class="comment">// cout &lt;&lt; "SoundPerSec - dens=" &lt;&lt; dens &lt;&lt; " areas=" &lt;&lt; areas &lt;&lt; " underOne="</span>
01407   <span class="comment">// &lt;&lt; underOne &lt;&lt; " soundsPsec=" &lt;&lt; soundsPsec &lt;&lt; endl;</span>
01408 
01409   <span class="keywordflow">return</span> soundsPsec;
01410 }
01411 
01412 
01413 
01414 <span class="comment">//----------------------------------------------------------------------------//</span>
01415 
01416 
01417 <span class="comment">//----------------------------------------------------------------------------//</span>
01418 <span class="comment">/*</span>
01419 <span class="comment">*/</span>
<a name="l01420"></a><a class="code" href="utility_8cpp.html#a23">01420</a> <span class="keywordtype">void</span> <a class="code" href="utility_8cpp.html#a23">GSection</a> (<a class="code" href="classList.html">List&lt;int&gt;</a> &amp;aList, <span class="keywordtype">int</span> levels) {
01421 
01422   <span class="keywordtype">int</span> strong;
01423   <span class="keywordtype">int</span> weak;
01424 
01425   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> counter = 1; counter &lt;= levels; counter++) {
01426     <span class="keywordtype">int</span> j = 1;
01427     aList.<a class="code" href="classList.html#a11">Head</a>();
01428 
01429     <span class="keywordflow">while</span> (j &lt;= pow(3., counter-1)) {
01430       <span class="keywordtype">int</span> from = aList.<a class="code" href="classList.html#a15">Retrieve</a>();
01431       aList++;
01432       <span class="keywordtype">int</span> length = aList.<a class="code" href="classList.html#a15">Retrieve</a>() - from;
01433       <span class="comment">// strong = int(floor(length * GOLDENMEAN + .5));</span>
01434       strong = int(floor(length * 6.182 + .5));     <span class="comment">// why ?????</span>
01435       weak = length - strong;
01436       aList.<a class="code" href="classList.html#a8">InsertInOrder</a>(weak + from);
01437       aList.<a class="code" href="classList.html#a8">InsertInOrder</a>(strong + from);
01438       aList++;
01439       j++;
01440     }
01441   }
01442 }
01443 <span class="comment">//----------------------------------------------------------------------------//</span>
01444 
01445 
01446 <span class="comment">//----------------------------------------------------------------------------//</span>
01447 <span class="comment">/*</span>
01448 <span class="comment">  RandomSource</span>
01449 <span class="comment">  </span>
01450 <span class="comment">  This function returns a random double, from 0-1</span>
01451 <span class="comment">*/</span>
01452 <span class="comment">/*</span>
01453 <span class="comment">double RandomSource() {</span>
01454 <span class="comment">  return (double) rand() / (double) RAND_MAX;</span>
01455 <span class="comment">}</span>
01456 <span class="comment">*/</span>
01457 <span class="comment">//----------------------------------------------------------------------------//</span>
01458 
01459 
01460 <span class="comment">//----------------------------------------------------------------------------//</span>
01461 <span class="comment">/*</span>
01462 <span class="comment">  RandRange</span>
01463 <span class="comment">  </span>
01464 <span class="comment">  This function returns a random value within the range of low to high.</span>
01465 <span class="comment">*/</span>
01466 <span class="comment">/*</span>
01467 <span class="comment">double RandRange (float low, float high) {</span>
01468 <span class="comment">  return RandomSource() * (high - low) + low;</span>
01469 <span class="comment">}</span>
01470 <span class="comment">*/</span>
01471 <span class="comment">//----------------------------------------------------------------------------//</span>
01472 
01473 
01474 <span class="comment">//----------------------------------------------------------------------------//</span>
01475 <span class="comment">/*</span>
01476 <span class="comment">  RandomTri</span>
01477 <span class="comment">  </span>
01478 <span class="comment">  This function takes two random numbers, averages them, and then returns that number scaled</span>
01479 <span class="comment">  into the range dictated by low to high.</span>
01480 <span class="comment">*/</span>
01481 <span class="comment">/*</span>
01482 <span class="comment">double RandomTri (float low, float high) {</span>
01483 <span class="comment">  return (RandomSource() + RandomSource()) * 0.5 * (high - low) + low;</span>
01484 <span class="comment">}</span>
01485 <span class="comment">*/</span>
01486 <span class="comment">//----------------------------------------------------------------------------//</span>
01487 
01488 
01489 <span class="comment">//---------------------------------------------------------------------------//</span>
01490 <span class="comment">/*</span>
01491 <span class="comment">  PreferedValueDistribution</span>
01492 <span class="comment">  </span>
01493 <span class="comment"></span>
01494 <span class="comment">*/</span>
01495 
<a name="l01496"></a><a class="code" href="utility_8cpp.html#a24">01496</a> <span class="keywordtype">float</span> <a class="code" href="utility_8cpp.html#a24">PreferedValueDistribution</a>(<span class="keywordtype">float</span> value, <span class="keywordtype">double</span> checkPoint) {
01497   <span class="keywordtype">double</span> probability;
01498 
01499   probability = exp(FIRST_CONST + SECOND_CONST * pow(2, (value - 0.5)) *
01500     pow(2, checkPoint));
01501 
01502   <span class="keywordflow">return</span> probability;
01503 }
01504 
01505 <span class="comment">//----------------------------------------------------------------------------//</span>
01506 
01507 
01508 <span class="comment">//----------------------------------------------------------------------------//</span>
01509 <span class="comment">/*</span>
01510 <span class="comment">  Chance</span>
01511 <span class="comment"></span>
01512 <span class="comment">  This function takes a flag, a point to check at, and an offset.  It then chooses</span>
01513 <span class="comment">  a random number from 0-1, and reads at the checkpoint either a number less than one,</span>
01514 <span class="comment">  or if the flag is set and is greater than one, returns true if the random number</span>
01515 <span class="comment">  chosen is less than the value of probability after the decimal point.</span>
01516 <span class="comment">*/</span>
<a name="l01517"></a><a class="code" href="utility_8cpp.html#a25">01517</a> <span class="keywordtype">bool</span> <a class="code" href="utility_8cpp.html#a26">Chance</a>(<span class="keywordtype">int</span> goFlag, <span class="keywordtype">double</span> checkPoint, <span class="keywordtype">int</span> offset) {
01518   <span class="keywordtype">float</span> probability;
01519   <span class="keywordtype">double</span> randomNumber = <a class="code" href="classRandom.html#e1">Random::Rand</a>();
01520 
01521   Envelope * env;                                           <span class="comment">// create an Envelope</span>
01522 
01523   <span class="comment">// USING NEW EnvelopeBuilder NOW</span>
01524   Envelope *newEnv = <a class="code" href="utility_8h.html#a19">EnvelopeBuilder</a>(<span class="stringliteral">"FROM_LIB_FIT"</span>, NULL, NULL, checkPoint,
01525    offset, 0, 0);
01526 
01527   <span class="comment">// HERE'S THE OLD WAY</span>
01528   <span class="comment">// env = FitEnvelope(checkPoint, offset);</span>
01529 
01530   probability = newEnv-&gt;getValue((<span class="keywordtype">float</span>)checkPoint, 1.);    <span class="comment">// prob of occurrence</span>
01531 
01532   <span class="keywordflow">if</span>(probability &lt; 0) {
01533     probability = goFlag;
01534   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(probability &gt; 1) {
01535     <span class="keywordflow">if</span>(goFlag == 1) {
01536       probability = 0;
01537     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(goFlag == 0) {
01538       probability -= (<span class="keywordtype">int</span>)probability;
01539     }
01540   }
01541 
01542   <span class="comment">//cout &lt;&lt; "         probability=" &lt;&lt; probability &lt;&lt; " randomNumber=" &lt;&lt;</span>
01543   <span class="comment">// randomNumber &lt;&lt; " goFlag=" &lt;&lt; goFlag &lt;&lt; endl;</span>
01544 
01545   <span class="keywordflow">return</span> (randomNumber &lt;= probability); 
01546 }
01547 
01548 
01549 <span class="comment">//----------------------------------------------------------------------------//</span>
01550 <span class="comment">/*</span>
01551 <span class="comment">  Chance</span>
01552 <span class="comment"></span>
01553 <span class="comment">  This function takes  a point to check at and an envelope.  It then chooses</span>
01554 <span class="comment">  a random number from 0-1, and reads at the checkpoint of the envelope.  If the </span>
01555 <span class="comment">  random number is less than or equal to the value at the checkpoint, return true, else</span>
01556 <span class="comment">  return false.</span>
01557 <span class="comment">*/</span>
<a name="l01558"></a><a class="code" href="utility_8cpp.html#a26">01558</a> <span class="keywordtype">bool</span> <a class="code" href="utility_8cpp.html#a26">Chance</a>(<span class="keywordtype">double</span> checkPoint, Envelope *chanceEnv) {
01559   <span class="keywordtype">float</span> probability;
01560   <span class="keywordtype">double</span> randomNumber = <a class="code" href="classRandom.html#e1">Random::Rand</a>();
01561 
01562   Envelope * env;                                           <span class="comment">// create an Envelope</span>
01563 
01564   probability = chanceEnv-&gt;getValue((<span class="keywordtype">float</span>)checkPoint, 1.);     <span class="comment">// prob of occurrence</span>
01565 
01566   <span class="comment">//cout &lt;&lt; "         probability=" &lt;&lt; probability &lt;&lt; " randomNumber=" &lt;&lt;</span>
01567   <span class="comment">// randomNumber &lt;&lt; " goFlag=" &lt;&lt; goFlag &lt;&lt; endl;</span>
01568 
01569   <span class="keywordflow">return</span> (randomNumber &lt;= probability); 
01570 }
01571 
01572 
01573 <span class="comment">//----------------------------------------------------------------------------//</span>
01574 <span class="comment">/*</span>
01575 <span class="comment">  Randomizer</span>
01576 <span class="comment">  </span>
01577 <span class="comment">  This function returns a random number between -1 and 1.</span>
01578 <span class="comment">*/</span>
01579 <span class="comment">/*</span>
01580 <span class="comment">double Randomizer() {</span>
01581 <span class="comment">  int plusMinus;</span>
01582 <span class="comment">  double extra, rand; </span>
01583 <span class="comment"></span>
01584 <span class="comment">  rand = RandomSource();</span>
01585 <span class="comment">    </span>
01586 <span class="comment">  if(rand &lt;= 0.5) {</span>
01587 <span class="comment">    plusMinus = 1;</span>
01588 <span class="comment">  } else if( rand &gt; 0.5) {</span>
01589 <span class="comment">    plusMinus = -1;</span>
01590 <span class="comment">  }</span>
01591 <span class="comment"></span>
01592 <span class="comment">  return extra = plusMinus * RandomSource();</span>
01593 <span class="comment">}</span>
01594 <span class="comment">*/</span>
01595 
01596 <span class="comment">//----------------------------------------------------------------------------//</span>
01597 
01598 
01599 <span class="comment">//----------------------------------------------------------------------------//</span>
01600 <span class="comment">/*</span>
01601 <span class="comment">  ChooseA</span>
01602 <span class="comment">  </span>
01603 <span class="comment">  Given an array of probabilities of length size, this function returns a random index</span>
01604 <span class="comment">  by selecting a random number and returning the index of the first probability whos value is</span>
01605 <span class="comment">  greater than the random number.</span>
01606 <span class="comment">*/</span>
<a name="l01607"></a><a class="code" href="utility_8cpp.html#a27">01607</a> <span class="keywordtype">int</span> <a class="code" href="utility_8cpp.html#a27">ChooseA</a> (<span class="keywordtype">double</span> probs[], <span class="keywordtype">int</span> size) {
01608   <span class="keywordtype">double</span> randomNumber = <a class="code" href="classRandom.html#e1">Random::Rand</a>();
01609 
01610   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; size; i++) {
01611     <span class="keywordflow">if</span>(randomNumber &lt;= probs [i]) {
01612       <span class="keywordflow">return</span> i; 
01613     }
01614   }
01615 
01616   <span class="comment">/* if(probArray != NULL) {            //is this OK ??????</span>
01617 <span class="comment">       Clear(probArray, arraySize);</span>
01618 <span class="comment">     } */</span>
01619 }
01620 <span class="comment">//----------------------------------------------------------------------------//</span>
01621 
01622 
01623 <span class="comment">//-----------------------------------------------------------------------/</span>
01624 <span class="comment">/*</span>
01625 <span class="comment">  ChooseFromList</span>
01626 <span class="comment">  </span>
01627 <span class="comment">  This function returns a random element of the array array[].</span>
01628 <span class="comment">*/</span>
<a name="l01629"></a><a class="code" href="utility_8cpp.html#a28">01629</a> <span class="keywordtype">float</span> <a class="code" href="utility_8cpp.html#a28">ChooseFromList</a> (<span class="keywordtype">float</span> array[], <span class="keywordtype">int</span> size) {
01630   <span class="keywordtype">double</span> randomNumber = <a class="code" href="classRandom.html#e1">Random::Rand</a>();
01631 
01632   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
01633     <span class="keywordflow">if</span>(randomNumber &lt;= (<span class="keywordtype">float</span>)(i + 1) / (<span class="keywordtype">float</span>)size) {
01634       <span class="keywordflow">return</span> array [i];
01635     }
01636   }
01637 }
01638 <span class="comment">//----------------------------------------------------------------------------//</span>
01639 
01640 
01641 <span class="comment">//----------------------------------------------------------------------------//</span>
01642 <span class="comment">/*</span>
01643 <span class="comment">  FlatDistribution</span>
01644 <span class="comment"></span>
01645 <span class="comment">*/</span>
01646 <span class="comment">/*</span>
01647 <span class="comment">void FlatDistribution(List&lt;double&gt; &amp;aProbList) {</span>
01648 <span class="comment">  aProbList.Head();</span>
01649 <span class="comment">  int len = aProbList.Length();</span>
01650 <span class="comment">  double prob = 0.;</span>
01651 <span class="comment"></span>
01652 <span class="comment">  for(int j = 0; j &lt; len; j++){</span>
01653 <span class="comment">    prob += 1. / (float) len ;</span>
01654 <span class="comment">    aProbList.Update(prob);</span>
01655 <span class="comment">    aProbList++;</span>
01656 <span class="comment">  }</span>
01657 <span class="comment">}</span>
01658 <span class="comment">*/</span>
01659 <span class="comment">//----------------------------------------------------------------------------//</span>
01660 
01661 
01662 <span class="comment">//---------------------------------------------------------------------------/</span>
01663 <span class="comment">/*</span>
01664 <span class="comment">  RandomNumber</span>
01665 <span class="comment">  </span>
01666 <span class="comment">  This function returns a random integer between lowNum and highNum</span>
01667 <span class="comment">*/</span>
01668 <span class="comment">/*</span>
01669 <span class="comment">int RandomNumber(int lowNum, int highNum) {</span>
01670 <span class="comment">  return (lowNum + rand() % (highNum - lowNum + 1));</span>
01671 <span class="comment">}</span>
01672 <span class="comment">*/</span>
01673 <span class="comment">//----------------------------------------------------------------------------//</span>
01674 
01675 
01676 <span class="comment">//----------------------------------------------------------------------------//</span>
01677 <span class="comment">/*</span>
01678 <span class="comment">   Weights</span>
01679 <span class="comment"></span>
01680 <span class="comment">   Deprecated, see sieve.cpp</span>
01681 <span class="comment">*/</span>
01682 <span class="comment">/*</span>
01683 <span class="comment">void Weights(double probArray[], int listLen) {</span>
01684 <span class="comment">  int i, levels;</span>
01685 <span class="comment">  double sumProb = 0;</span>
01686 <span class="comment">  char * method;</span>
01687 <span class="comment"></span>
01688 <span class="comment">  DataIn w; w.ReadDummies();</span>
01689 <span class="comment">  w.ReadChars(1);</span>
01690 <span class="comment">  method = w.nameOf[0];</span>
01691 <span class="comment"></span>
01692 <span class="comment">  // How many weights in the sieve and what are they</span>
01693 <span class="comment">  w.ReadInts(1);</span>
01694 <span class="comment">  levels = w.intVect[0];</span>
01695 <span class="comment">  w.ReadInts(levels);</span>
01696 <span class="comment"></span>
01697 <span class="comment">  for(int count = 0; count &lt; listLen; count++) {</span>
01698 <span class="comment">    int lev = 0;</span>
01699 <span class="comment">    double prob = 0;</span>
01700 <span class="comment"></span>
01701 <span class="comment">    if(strcmp(method, "HIERARCHIC") == 0) {             // hierarchic</span>
01702 <span class="comment">        while (lev &lt; levels) {</span>
01703 <span class="comment">          if(count % w.intVect [lev] == 0) {</span>
01704 <span class="comment">            prob += w.intVect [lev]; </span>
01705 <span class="comment">          }</span>
01706 <span class="comment">          lev++;</span>
01707 <span class="comment">        }</span>
01708 <span class="comment">    } else if(strcmp(method, "PERIODIC") == 0) {        // periodic</span>
01709 <span class="comment">        prob = w.intVect[count % levels];</span>
01710 <span class="comment">    } else {</span>
01711 <span class="comment">      cout &lt;&lt; "Utility::Weights - no method for sieve weights" &lt;&lt; endl;</span>
01712 <span class="comment">      cin &gt;&gt; sever;</span>
01713 <span class="comment">    }</span>
01714 <span class="comment"></span>
01715 <span class="comment">    probArray[count] = prob;</span>
01716 <span class="comment">    sumProb += prob;</span>
01717 <span class="comment">  }</span>
01718 <span class="comment"></span>
01719 <span class="comment">  for(int count = 0; count &lt; listLen; count++) {</span>
01720 <span class="comment">    probArray[count] /= sumProb;</span>
01721 <span class="comment">  }</span>
01722 <span class="comment">}</span>
01723 <span class="comment">*/</span>
01724 
01725 <span class="comment">//----------------------------------------------------------------------------//</span>
01726 
01727 
01728 <span class="comment">//----------------------------------------------------------------------------//</span>
01729 <span class="comment">/*</span>
01730 <span class="comment">   Clear</span>
01731 <span class="comment"></span>
01732 <span class="comment">   This function takes an array, and "clears" it by pointing it to null.</span>
01733 <span class="comment">*/</span>
<a name="l01734"></a><a class="code" href="utility_8cpp.html#a29">01734</a> <span class="keywordtype">void</span> <a class="code" href="utility_8cpp.html#a29">Clear</a>(<span class="keywordtype">double</span> probArray[], <span class="keywordtype">int</span> arraySize) {
01735   <a class="code" href="utility_8h.html#a0">probArray</a> = NULL;
01736 }
01737 <span class="comment">//----------------------------------------------------------------------------//</span>
01738 
01739 
01740 <span class="comment">//----------------------------------------------------------------------------//</span>
01741 <span class="comment">/*</span>
01742 <span class="comment">   Exponential</span>
01743 <span class="comment"></span>
01744 <span class="comment">   This function models exponential decay or growth.</span>
01745 <span class="comment">*/</span>
<a name="l01746"></a><a class="code" href="utility_8cpp.html#a30">01746</a> <span class="keywordtype">double</span> <a class="code" href="utility_8cpp.html#a30">Exponential</a>(<span class="keywordtype">int</span> step, <span class="keywordtype">double</span> extra) {
01747   <span class="keywordtype">double</span> value;
01748 
01749   value = 1. / pow(2.71828, step);
01750   value += (extra * value);
01751 
01752   <span class="keywordflow">return</span> value;
01753 }
01754 <span class="comment">//----------------------------------------------------------------------------//</span>
01755 
01756 
01757 <span class="comment">//---------------------------------------------------------------------------//</span>
01758 <span class="comment">/*</span>
01759 <span class="comment">  Sum</span>
01760 <span class="comment">  </span>
01761 <span class="comment">  This function returns the sum of the elements in the array passed in.</span>
01762 <span class="comment">*/</span>
<a name="l01763"></a><a class="code" href="utility_8cpp.html#a31">01763</a> <span class="keywordtype">float</span> <a class="code" href="utility_8cpp.html#a31">Sum</a>(<span class="keywordtype">double</span> array[], <span class="keywordtype">int</span> size) {
01764   <span class="keywordtype">double</span> sum;
01765 
01766   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i , size; i++) {
01767     sum = array[i];
01768   }
01769 
01770   <span class="keywordflow">return</span> sum;
01771 }
01772 <span class="comment">//----------------------------------------------------------------------------//</span>
01773 
01774 
01775 <span class="comment">//---------------------------------------------------------------------------//</span>
01776 <span class="comment">/*</span>
01777 <span class="comment">  Normalize</span>
01778 <span class="comment">  </span>
01779 <span class="comment">  This function scales the values in the array to hold the same weight as previously,</span>
01780 <span class="comment">  but the sum of the values is now 1. Each value is now between 0 and 1.</span>
01781 <span class="comment">*/</span>
<a name="l01782"></a><a class="code" href="utility_8cpp.html#a32">01782</a> <span class="keywordtype">void</span> <a class="code" href="utility_8cpp.html#a32">Normalize</a>(<span class="keywordtype">double</span> array[], <span class="keywordtype">int</span> size) {
01783   <span class="keywordtype">double</span> sum;
01784   
01785   sum = <a class="code" href="utility_8cpp.html#a31">Sum</a>(array, size);
01786 
01787   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
01788     array[i] /= sum; 
01789   }
01790 }
01791 <span class="comment">//----------------------------------------------------------------------------//</span>
01792 
01793 
01794 <span class="comment">//----------------------------------------------------------------------------//</span>
01795 <span class="comment">/*</span>
01796 <span class="comment">  TestLibrary</span>
01797 <span class="comment">*/</span>
<a name="l01798"></a><a class="code" href="utility_8cpp.html#a33">01798</a> <span class="keywordtype">void</span> <a class="code" href="utility_8cpp.html#a33">TestLibrary</a> () {
01799   <span class="keywordtype">int</span> start, end;
01800   <span class="keywordtype">float</span> coef;
01801   <span class="keywordtype">char</span> * answer;
01802   <span class="keyword">extern</span> EnvelopeLibrary <a class="code" href="bottom_8cpp.html#a1">envlib</a>;
01803 
01804   Envelope *env;      <span class="comment">// create an Envelope</span>
01805 
01806   cout &lt;&lt; <span class="stringliteral">"TestLibrary - enter envelope numbers to be tested: from __ to __ "</span> &lt;&lt; endl;
01807   cin &gt;&gt; start, end;
01808   cout &lt;&lt; <span class="stringliteral">"  should the envelopes be scaled ? (Y-N)"</span> &lt;&lt; endl;
01809   cin &gt;&gt; answer;
01810 
01811   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> envNum = start; envNum &lt;= end; envNum++) {
01812 
01813     <span class="comment">// get an envelope from the library and scale it</span>
01814     env = <a class="code" href="bottom_8cpp.html#a1">envlib</a>.getEnvelope(envNum);
01815 
01816     <span class="keywordflow">if</span>(strcmp(answer, <span class="stringliteral">"y"</span>) == 0 || strcmp(answer, <span class="stringliteral">"Y"</span>) == 0) {
01817       cout &lt;&lt; <span class="stringliteral">"  enter scaling coefficient for envelope # "</span> &lt;&lt; envNum &lt;&lt; endl;
01818       cin &gt;&gt; coef;
01819       env-&gt;scale(coef);
01820     }
01821     cout &lt;&lt; <span class="stringliteral">"                Envelope # "</span> &lt;&lt; envNum &lt;&lt; endl;
01822     env-&gt;Print();
01823     cin &gt;&gt; <a class="code" href="main_8cpp.html#a7">sever</a>;
01824   }
01825 }
01826 
01827 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l01828"></a><a class="code" href="utility_8cpp.html#a34">01828</a> <span class="keywordtype">void</span> *<a class="code" href="utility_8cpp.html#a34">Evaluate</a> (<a class="code" href="classFileValue.html">FileValue</a> *value)
01829 {
01830     <span class="keywordflow">if</span> (value == NULL)
01831     {
01832         cout &lt;&lt; <span class="stringliteral">"NULL value\n"</span>;
01833         <span class="keywordflow">return</span> NULL;
01834     }
01835     <span class="keywordflow">if</span> (value-&gt;<a class="code" href="classFileValue.html#a17">isNumber</a>())
01836     {
01837         <span class="keywordtype">double</span> *val = <span class="keyword">new</span> double(value-&gt;<a class="code" href="classFileValue.html#a6">getNumber</a>());
01838         <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)val;
01839     }
01840     <span class="keywordflow">if</span> (value-&gt;<a class="code" href="classFileValue.html#a19">isString</a>())
01841     {
01842         string *val = <span class="keyword">new</span> string(value-&gt;<a class="code" href="classFileValue.html#a5">getString</a>());
01843         <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)val;
01844     }
01845     <span class="keywordflow">if</span> (value-&gt;<a class="code" href="classFileValue.html#a18">isList</a>())
01846     {
01847         <span class="comment">// do stuff here... not return null...</span>
01848         <span class="keywordflow">return</span> NULL;
01849     }
01850     <span class="keywordflow">else</span>
01851     {
01852         <span class="keywordflow">return</span> NULL;
01853     }
01854 }
01855 <span class="comment">//---------------------------------------------------------------------------//</span>
<a name="l01856"></a><a class="code" href="utility_8cpp.html#a35">01856</a> <a class="code" href="classFileValue.html">FileValue</a> <a class="code" href="utility_8cpp.html#a35">Select</a>(std::list&lt;FileValue&gt; l, <span class="keywordtype">int</span> n)
01857 {
01858     <span class="comment">// remmeber to test for bounds</span>
01859     std::list&lt;FileValue&gt;::const_iterator iter;
01860     iter = l.begin();
01861     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
01862         iter++;
01863     <span class="keywordflow">return</span> *(iter);
01864 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Feb 12 14:24:38 2007 for CMOD by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
