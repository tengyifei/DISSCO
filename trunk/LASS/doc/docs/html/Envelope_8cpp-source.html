<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LASS: Envelope.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Envelope.cpp</h1><a href="Envelope_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">LASS (additive sound synthesis library)</span>
00003 <span class="comment">Copyright (C) 2005  Sever Tipei (s-tipei@uiuc.edu)</span>
00004 <span class="comment"></span>
00005 <span class="comment">This program is free software; you can redistribute it and/or</span>
00006 <span class="comment">modify it under the terms of the GNU General Public License</span>
00007 <span class="comment">as published by the Free Software Foundation; either version 2</span>
00008 <span class="comment">of the License, or (at your option) any later version.</span>
00009 <span class="comment"></span>
00010 <span class="comment">This program is distributed in the hope that it will be useful,</span>
00011 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00012 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00013 <span class="comment">GNU General Public License for more details.</span>
00014 <span class="comment"></span>
00015 <span class="comment">You should have received a copy of the GNU General Public License</span>
00016 <span class="comment">along with this program; if not, write to the Free Software</span>
00017 <span class="comment">Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
00018 <span class="comment">*/</span>
00019 
00020 <span class="comment">//----------------------------------------------------------------------------//</span>
00021 <span class="comment">//</span>
00022 <span class="comment">// Envelope.cpp</span>
00023 <span class="comment">//</span>
00024 <span class="comment">//----------------------------------------------------------------------------//</span>
00025 
00026 <span class="preprocessor">#ifndef __ENVELOPE_CPP</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define __ENVELOPE_CPP</span>
00028 <span class="preprocessor"></span>
00029 <span class="comment">// #define DEBUG_MODE 1</span>
00030 
00031 <span class="comment">//----------------------------------------------------------------------------//</span>
00032 
00033 <span class="preprocessor">#include "<a class="code" href="Envelope_8h.html">Envelope.h</a>"</span>
00034 <span class="preprocessor">#include "<a class="code" href="EnvelopeIterator_8h.html">EnvelopeIterator.h</a>"</span>
00035 <span class="preprocessor">#include "<a class="code" href="InterpolatorTypes_8h.html">InterpolatorTypes.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="code" href="lib_8h.html">lib.h</a>"</span>
00037 
00038 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00039 <span class="preprocessor">#include &lt;math.h&gt;</span>
00040 <span class="keyword">using</span> std::setw;
00041 
00042 
00043 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00044"></a><a class="code" href="classEnvelope.html#a0">00044</a> <a class="code" href="classEnvelope.html#a0">Envelope::Envelope</a>()
00045 {
00046     <a class="code" href="classEnvelope.html#r0">segments_</a> = NULL;
00047     <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a> = NULL;
00048     <a class="code" href="classEnvelope.html#r1">interpolators_</a> = NULL;
00049     <a class="code" href="classEnvelope.html#r3">totalLength_</a> = -1;
00050     <a class="code" href="classEnvelope.html#r4">currentInterpolatorRate_</a> = 0;
00051 }
00052 
00053 
<a name="l00054"></a><a class="code" href="classEnvelope.html#a1">00054</a> <a class="code" href="classEnvelope.html#a0">Envelope::Envelope</a> (<a class="code" href="classEnvelope.html">Envelope</a> &amp;env)
00055 {
00056     <a class="code" href="classEnvelope.html#r0">segments_</a> = env.<a class="code" href="classEnvelope.html#a13">getSegments</a>();
00057 
00058     <span class="comment">// there's not an easy way to transfer these, so the copy does not contain</span>
00059     <span class="comment">// the generated interpolators, but these are only stored to help</span>
00060     <span class="comment">// optimize the code</span>
00061     <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a> = NULL;
00062     <a class="code" href="classEnvelope.html#r1">interpolators_</a> = NULL;
00063     <a class="code" href="classEnvelope.html#r3">totalLength_</a> = -1;
00064     <a class="code" href="classEnvelope.html#r4">currentInterpolatorRate_</a> = 0;
00065 }
00066 
00067 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00068"></a><a class="code" href="classEnvelope.html#a2">00068</a> <a class="code" href="classEnvelope.html#a0">Envelope::Envelope</a>(<a class="code" href="classCollection.html">Collection&lt;xy_point&gt;</a> xy_points, <a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a> segs)
00069 {
00070   <a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a> segments;
00071   <a class="code" href="structenvelope__segment.html">envelope_segment</a> seg;
00072   <a class="code" href="structxy__point.html">xy_point</a> tpt = xy_points.<a class="code" href="classCollection.html#a7">get</a>(0);
00073   seg.<a class="code" href="structenvelope__segment.html#o5">x</a> = tpt.<a class="code" href="structxy__point.html#o0">x</a>; seg.<a class="code" href="structenvelope__segment.html#o6">y</a> = tpt.<a class="code" href="structxy__point.html#o1">y</a>;
00074   segments.<a class="code" href="classCollection.html#a4">add</a>(seg);
00075   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; xy_points.<a class="code" href="classCollection.html#a10">size</a>(); i++)
00076     {
00077       seg = segs.<a class="code" href="classCollection.html#a7">get</a>(i-1);
00078       seg.<a class="code" href="structenvelope__segment.html#o5">x</a> = xy_points.<a class="code" href="classCollection.html#a7">get</a>(i).x;
00079       seg.<a class="code" href="structenvelope__segment.html#o6">y</a> = xy_points.<a class="code" href="classCollection.html#a7">get</a>(i).y;
00080       segments.<a class="code" href="classCollection.html#a4">add</a>(seg);
00081     }
00082   
00083     <a class="code" href="classEnvelope.html#r0">segments_</a> = NULL;
00084     <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a> = NULL;
00085     <a class="code" href="classEnvelope.html#r1">interpolators_</a> = NULL;
00086     <a class="code" href="classEnvelope.html#r3">totalLength_</a> = -1;
00087     <a class="code" href="classEnvelope.html#r4">currentInterpolatorRate_</a> = 0;
00088 
00089     <span class="comment">// define the shape, given the Collection</span>
00090     <a class="code" href="classEnvelope.html#a8">DefineShape</a> (segments);  
00091 }
00092 
00093 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00094"></a><a class="code" href="classEnvelope.html#a3">00094</a> <a class="code" href="classEnvelope.html#a0">Envelope::Envelope</a>(<a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a> segs)
00095 {
00096     <a class="code" href="classEnvelope.html#r0">segments_</a> = NULL;
00097     <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a> = NULL;
00098     <a class="code" href="classEnvelope.html#r1">interpolators_</a> = NULL;
00099     <a class="code" href="classEnvelope.html#r3">totalLength_</a> = -1;
00100     <a class="code" href="classEnvelope.html#r4">currentInterpolatorRate_</a> = 0;
00101 
00102     <span class="comment">// define the shape, given the Collections</span>
00103     <a class="code" href="classEnvelope.html#a8">DefineShape</a> (segs);
00104 
00105 }
00106 
00107 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00108"></a><a class="code" href="classEnvelope.html#a4">00108</a> <a class="code" href="classEnvelope.html#a4">Envelope::~Envelope</a>()
00109 {
00110     <span class="comment">// make sure we don't cause a memory leak</span>
00111     <span class="keywordflow">if</span> (<a class="code" href="classEnvelope.html#r0">segments_</a> != NULL)
00112     {
00113         <span class="keyword">delete</span> (<a class="code" href="classEnvelope.html#r0">segments_</a>);
00114     }
00115     <span class="keywordflow">if</span> (<a class="code" href="classEnvelope.html#r1">interpolators_</a> != NULL)
00116     {
00117         <a class="code" href="classInterpolator.html">Interpolator</a>* interTemp = NULL;
00118 
00119         <span class="comment">// remove each interpolator* from the collection and delete the</span>
00120         <span class="comment">// allocated memory</span>
00121         <span class="keywordflow">while</span> (<a class="code" href="classEnvelope.html#r1">interpolators_</a>-&gt;<a class="code" href="classCollection.html#a10">size</a>() &gt; 0)
00122         {
00123             interTemp = <a class="code" href="classEnvelope.html#r1">interpolators_</a>-&gt;<a class="code" href="classCollection.html#a8">remove</a>(0);
00124             <span class="keyword">delete</span> (interTemp);
00125         }
00126 
00127         <span class="keyword">delete</span> (<a class="code" href="classEnvelope.html#r1">interpolators_</a>);
00128     }
00129     <span class="keywordflow">if</span> (<a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a> != NULL)
00130     {
00131         <span class="keyword">delete</span> (<a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>);
00132     }
00133 }
00134 
00135 
00136 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00137"></a><a class="code" href="classEnvelope.html#a7">00137</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a7">Envelope::Print</a>()
00138 {
00139     <span class="keywordflow">if</span> (<a class="code" href="classEnvelope.html#r0">segments_</a> == NULL)
00140       {
00141         cout &lt;&lt; <span class="stringliteral">"Envelope has not been initialized.\n"</span>;
00142         <span class="keywordflow">return</span>;
00143       }
00144 
00145     <span class="keywordtype">int</span> iNumSegments = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a10">size</a>();
00146     <span class="keywordtype">int</span> iLoop = 0;
00147 
00148     cout &lt;&lt; endl;
00149     cout &lt;&lt; <span class="stringliteral">"Envelope has "</span> &lt;&lt; iNumSegments-1 &lt;&lt; <span class="stringliteral">" segments."</span> &lt;&lt; endl;
00150 
00151     <span class="keywordflow">for</span> (iLoop = 0; iLoop &lt; iNumSegments-1; iLoop++)
00152     {
00153         <span class="comment">// print a line with form (x, y):</span>
00154         cout &lt;&lt; <span class="stringliteral">" x, y: "</span> &lt;&lt; <span class="stringliteral">"("</span>;
00155         cout &lt;&lt; setw(5) &lt;&lt; <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iLoop).<a class="code" href="structenvelope__segment.html#o5">x</a>;
00156         cout &lt;&lt; <span class="stringliteral">", "</span>;
00157         cout &lt;&lt; setw(5) &lt;&lt; <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iLoop).<a class="code" href="structenvelope__segment.html#o6">y</a>;
00158         cout &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl;
00159 
00160         <span class="comment">// print the entry number</span>
00161         cout &lt;&lt; <span class="stringliteral">"     Entry "</span> &lt;&lt; iLoop &lt;&lt; <span class="stringliteral">":"</span> &lt;&lt; endl;
00162         
00163         <span class="comment">// print the length type</span>
00164         cout &lt;&lt; <span class="stringliteral">"       Length type: "</span>;
00165         <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classEnvelope.html#a22">getSegmentLengthType</a>(iLoop) == <a class="code" href="Types_8h.html#a12a8">FLEXIBLE</a>)
00166         {
00167             cout &lt;&lt; <span class="stringliteral">"FLEXIBLE"</span> &lt;&lt; endl;
00168         }
00169         <span class="keywordflow">else</span>
00170         {
00171             cout &lt;&lt; <span class="stringliteral">"FIXED"</span> &lt;&lt; endl;
00172         }
00173 
00174         <span class="comment">// print the length value</span>
00175         cout &lt;&lt; <span class="stringliteral">"       Length value: "</span>;
00176         cout &lt;&lt; this-&gt;<a class="code" href="classEnvelope.html#a20">getSegmentLength</a>(iLoop) &lt;&lt; endl;
00177 
00178         <span class="comment">// print the interpolation type</span>
00179         cout &lt;&lt; <span class="stringliteral">"       Interpolation Type: "</span>;
00180         <span class="keywordflow">switch</span> (this-&gt;<a class="code" href="classEnvelope.html#a24">getSegmentInterpolationType</a>(iLoop))
00181         {
00182             <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a13a11">LINEAR</a>:
00183                 cout &lt;&lt; <span class="stringliteral">"LINEAR"</span> &lt;&lt; endl;
00184                 <span class="keywordflow">break</span>;
00185             <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a13a9">EXPONENTIAL</a>:
00186                 cout &lt;&lt; <span class="stringliteral">"EXPONENTIAL"</span> &lt;&lt; endl;
00187                 <span class="keywordflow">break</span>;
00188             <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a13a10">CUBIC_SPLINE</a>:
00189                 cout &lt;&lt; <span class="stringliteral">"CUBIC_SPLINE"</span> &lt;&lt; endl;
00190                 <span class="keywordflow">break</span>;
00191         }
00192     }
00193 
00194     <span class="comment">// output the last point</span>
00195     cout &lt;&lt; <span class="stringliteral">" x, y: "</span> &lt;&lt; <span class="stringliteral">"("</span>;
00196     cout &lt;&lt; setw(5) &lt;&lt; <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iLoop).<a class="code" href="structenvelope__segment.html#o5">x</a>;
00197     cout &lt;&lt; <span class="stringliteral">", "</span>;
00198     cout &lt;&lt; setw(5) &lt;&lt; <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iLoop).<a class="code" href="structenvelope__segment.html#o6">y</a>;
00199     cout &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl;
00200     
00201     cout &lt;&lt; <span class="stringliteral">"End of Envelope."</span> &lt;&lt; endl;
00202     cout &lt;&lt; endl;
00203 }
00204 
00205 
00206 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00207"></a><a class="code" href="classEnvelope.html#a5">00207</a> <a class="code" href="classEnvelope.html">Envelope</a>* <a class="code" href="classEnvelope.html#a5">Envelope::clone</a> ()
00208 {
00209     <span class="comment">// give them a new envelope that is made using the current envelope's data</span>
00210     <span class="keywordflow">return</span> (<span class="keyword">new</span> <a class="code" href="classEnvelope.html#a0">Envelope</a>(*<a class="code" href="classEnvelope.html#r0">segments_</a>));
00211 }
00212 
00213 
00214 <span class="comment">//----------------------------------------------------------------------------//</span>
00215 
<a name="l00216"></a><a class="code" href="classEnvelope.html#a6">00216</a> <a class="code" href="Types_8h.html#a3">m_value_type</a> <a class="code" href="classEnvelope.html#a6">Envelope::getValue</a> (<a class="code" href="Types_8h.html#a3">m_value_type</a> x,
00217                                                 <a class="code" href="Types_8h.html#a3">m_value_type</a> totalLength)
00218 {
00219         <span class="keywordflow">if</span> (x &gt; totalLength || x &lt; 0)
00220         {
00221         <span class="comment">// they are dumb for passing in invalid values, so let them know</span>
00222                 cout &lt;&lt; <span class="stringliteral">"Envelope::getValue(...): invalid x or totalLength parameter"</span> &lt;&lt; endl;
00223         }
00224 
00225         <span class="comment">//Handle special case where absolute end of envelope is asked for</span>
00226         <span class="keywordflow">if</span>(x==totalLength)
00227         {
00228                 <span class="keywordflow">return</span> <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(<a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a10">size</a>()-1).<a class="code" href="structenvelope__segment.html#o6">y</a>;
00229         }
00230 
00231         <span class="comment">//TODO: Make come sort of cached flag that will see if this</span>
00232         <span class="comment">//      actually needs to be performed or not.</span>
00233         <a class="code" href="classEnvelope.html#d1">generateLengths</a>(totalLength);
00234         
00235         <span class="comment">//First, find the segment index that this x/totalLength refers to</span>
00236         <a class="code" href="Types_8h.html#a3">m_value_type</a> current=0;
00237         <span class="keywordtype">int</span> x_Index=0;
00238         <span class="keywordflow">while</span>(current&lt;x)
00239         {
00240                 current+=<a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(x_Index);
00241                 x_Index++;
00242         }
00243         
00244         <span class="comment">//If we have overshot, lets go back</span>
00245         <span class="keywordflow">if</span>(current!=x)
00246 
00247         {
00248                 x_Index--;
00249                 current-=<a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(x_Index);
00250         }
00251 
00252         <span class="comment">//Spawn an interpolator of the proper type</span>
00253         <a class="code" href="classInterpolator.html">Interpolator</a> *interp;
00254         <span class="keywordflow">switch</span> (<a class="code" href="classEnvelope.html#a24">getSegmentInterpolationType</a>(x_Index))
00255         {
00256             <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a13a9">EXPONENTIAL</a>:
00257                 interp=<span class="keyword">new</span> <a class="code" href="classExponentialInterpolator.html">ExponentialInterpolator</a>();
00258                 <span class="keywordflow">break</span>;
00259            
00260             <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a13a10">CUBIC_SPLINE</a>:
00261                 interp=<span class="keyword">new</span> <a class="code" href="classCubicSplineInterpolator.html">CubicSplineInterpolator</a>();
00262                 <span class="keywordflow">break</span>;
00263 
00264             <span class="keywordflow">default</span>: 
00265                 interp=<span class="keyword">new</span> <a class="code" href="classLinearInterpolator.html">LinearInterpolator</a>();
00266                 <span class="keywordflow">break</span>;
00267         }
00268 
00269         <span class="comment">// set the Interpolator's sampling rate to a fixed granularity</span>
00270         interp-&gt;<a class="code" href="classDynamicVariable.html#a8">setSamplingRate</a>(100);
00271 
00272         <span class="comment">// set interpolator duration to one second to make it easy</span>
00273         interp-&gt;<a class="code" href="classDynamicVariable.html#a6">setDuration</a>(1.0);
00274 
00275         <span class="comment">// We know that this segment interpolates between xy point</span>
00276         <span class="comment">// x_Index and x_Index+1</span>
00277         <a class="code" href="structxy__point.html">xy_point</a> left,right;
00278         left=<a class="code" href="classEnvelope.html#a17">getPoint</a>(x_Index);
00279         right=<a class="code" href="classEnvelope.html#a17">getPoint</a>(x_Index+1);
00280 
00281         <span class="comment">// Now tell the interpolator what values we are going between</span>
00282         interp-&gt;<a class="code" href="classInterpolator.html#a2">addEntry</a>(0,left.<a class="code" href="structxy__point.html#o1">y</a>);
00283         interp-&gt;<a class="code" href="classInterpolator.html#a2">addEntry</a>(1,right.<a class="code" href="structxy__point.html#o1">y</a>);
00284 
00285         <span class="comment">// Figure out which sample we want from the interpolator.</span>
00286         <span class="comment">// This is done by taking the percentage we have to iterate thru</span>
00287         <span class="comment">// the interpolator, and then multiplying that by the number of samples</span>
00288         <span class="keywordtype">int</span> sample=int(round(((x-current)/<a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(x_Index))*100.0));
00289 
00290         <span class="comment">// Create a value iterator to get values from the interpolator</span>
00291         <a class="code" href="classIterator.html">Iterator&lt;m_value_type&gt;</a> tempIterator=interp-&gt;<a class="code" href="classInterpolator.html#a3">valueIterator</a>();
00292 
00293         <span class="comment">// Now lets skip the first sample-1 samples...</span>
00294         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;sample;i++)
00295         {
00296                 tempIterator.<a class="code" href="classIterator.html#a5">next</a>();
00297         }
00298 
00299         <span class="comment">// Now grab the one we want</span>
00300         <a class="code" href="Types_8h.html#a3">m_value_type</a> returnval=tempIterator.<a class="code" href="classIterator.html#a5">next</a>();
00301 
00302         <span class="keyword">delete</span> interp;
00303 
00304         <span class="keywordflow">return</span> returnval;
00305 }
00306 
00307 
00308 <span class="comment">/* //The old getValue</span>
00309 <span class="comment">m_value_type Envelope::getValue (m_time_type time,</span>
00310 <span class="comment">                                                m_time_type totalLength)</span>
00311 <span class="comment">{</span>
00312 <span class="comment">    m_rate_type newSamplingRate = 50;</span>
00313 <span class="comment">    m_rate_type oldSamplingRate = this-&gt;getSamplingRate();</span>
00314 <span class="comment">    m_time_type oldDuration = this-&gt;getDuration();</span>
00315 <span class="comment">    m_value_type returnValue = 0;</span>
00316 <span class="comment"></span>
00317 <span class="comment">    if (time &gt; totalLength || time &lt; 0)</span>
00318 <span class="comment">    {</span>
00319 <span class="comment">        // they are dumb for passing in invalid values, so let them know</span>
00320 <span class="comment">        cout &lt;&lt; "Envelope::getValue(...): invalid time or totalLength parameter" &lt;&lt; endl;</span>
00321 <span class="comment">    }</span>
00322 <span class="comment">    else</span>
00323 <span class="comment">    {</span>
00324 <span class="comment">        // set the dynamic variable parameters to temporary values</span>
00325 <span class="comment">        this-&gt;setSamplingRate(newSamplingRate);</span>
00326 <span class="comment">        this-&gt;setDuration(totalLength);</span>
00327 <span class="comment"></span>
00328 <span class="comment">        // get an iterator for this shape</span>
00329 <span class="comment">        Iterator&lt;m_value_type&gt; *tempIterator =</span>
00330 <span class="comment">            new Iterator&lt;m_value_type&gt; (valueIterator());</span>
00331 <span class="comment"></span>
00332 <span class="comment">        // we can calculate how many samples are needed for the floor (time)</span>
00333 <span class="comment">        m_time_type timeSum = (m_time_type) floor ((double) time);</span>
00334 <span class="comment">        int iNumGetValCalls = newSamplingRate * ((int) floor (time));</span>
00335 <span class="comment"></span>
00336 <span class="comment">        // now, calculate how many samples are needed for (time - floor (time))</span>
00337 <span class="comment">        while (timeSum &lt; time)</span>
00338 <span class="comment">        {</span>
00339 <span class="comment">            timeSum = timeSum + (1.0 / newSamplingRate);    </span>
00340 <span class="comment">            iNumGetValCalls++;</span>
00341 <span class="comment">        }</span>
00342 <span class="comment"></span>
00343 <span class="comment">        // it seems to be a few samples off...this is a hack to get good values</span>
00344 <span class="comment">        iNumGetValCalls += 2;</span>
00345 <span class="comment"></span>
00346 <span class="comment">        // iterate, based on the values calculated</span>
00347 <span class="comment">        for (int iLoop = 0; iLoop &lt; iNumGetValCalls; iLoop++)</span>
00348 <span class="comment">        {</span>
00349 <span class="comment">            returnValue = tempIterator-&gt;next();</span>
00350 <span class="comment">        }</span>
00351 <span class="comment"></span>
00352 <span class="comment">        // cout &lt;&lt; "  iNumGetValCalls = " &lt;&lt; iNumGetValCalls &lt;&lt; endl;</span>
00353 <span class="comment">        // cout &lt;&lt; "  timeSum = " &lt;&lt; timeSum &lt;&lt; endl;</span>
00354 <span class="comment"></span>
00355 <span class="comment">        // set the dynamic variable paramaters back to what they were</span>
00356 <span class="comment">        this-&gt;setSamplingRate(oldSamplingRate);</span>
00357 <span class="comment">        this-&gt;setDuration(oldDuration);</span>
00358 <span class="comment">    }</span>
00359 <span class="comment"></span>
00360 <span class="comment">    return (returnValue);</span>
00361 <span class="comment"></span>
00362 <span class="comment">}</span>
00363 <span class="comment">*/</span>
00364 
00365 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00366"></a><a class="code" href="classEnvelope.html#a8">00366</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a8">Envelope::DefineShape</a> (<a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a> segs)
00367 {
00368     <span class="comment">// make sure we don't cause a memory leak</span>
00369     <span class="keywordflow">if</span> (<a class="code" href="classEnvelope.html#r0">segments_</a> != NULL)
00370     {
00371         <span class="keyword">delete</span> (<a class="code" href="classEnvelope.html#r0">segments_</a>);
00372     }
00373 
00374     <span class="comment">// set our local variables to copies of the variables passed in</span>
00375     <span class="comment">//maybe make this its own function???</span>
00376     <span class="comment">//===</span>
00377     <a class="code" href="structenvelope__segment.html">envelope_segment</a> temp_seg;
00378     <a class="code" href="Types_8h.html#a3">m_value_type</a> temp = 0;
00379     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;segs.<a class="code" href="classCollection.html#a10">size</a>(); i++)
00380       {
00381         temp_seg = segs.<a class="code" href="classCollection.html#a7">get</a>(i);
00382         temp_seg.<a class="code" href="structenvelope__segment.html#o4">length</a> = temp_seg.<a class="code" href="structenvelope__segment.html#o5">x</a> - temp;
00383         segs.<a class="code" href="classCollection.html#a9">set</a>(i, temp_seg);
00384         temp = temp_seg.<a class="code" href="structenvelope__segment.html#o5">x</a>;
00385       } 
00386     
00387     <a class="code" href="classEnvelope.html#r0">segments_</a> = <span class="keyword">new</span> <a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a> (segs);
00388 }
00389 
00390 <span class="comment">//----------------------------------------------------------------------------//</span>
00391 <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a9">Envelope::AddToShape</a>
<a name="l00392"></a><a class="code" href="classEnvelope.html#a9">00392</a> ( <a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a> segs)
00393 {
00394   <span class="comment">// case: Adding to an empty Collection</span>
00395   <span class="keywordflow">if</span> ( segments_ == NULL )
00396     {
00397       DefineShape(segs);
00398       <span class="keywordflow">return</span>;
00399     }
00400 
00401   <span class="keywordtype">int</span> iNumSegments = segs.size();
00402   <a class="code" href="Types_8h.html#a3">m_value_type</a> x_Offset = segments_-&gt;get(segments_-&gt;size() - 1).x;
00403   <a class="code" href="Types_8h.html#a3">m_value_type</a> x_Last = x_Offset;
00404   <a class="code" href="structenvelope__segment.html">envelope_segment</a> segTemp;
00405 
00406   <span class="comment">// verify that the last old point and the first new point have the</span>
00407   <span class="comment">// same y value (usually zero), that they can be appended</span>
00408   <span class="keywordflow">if</span> ( (segments_ -&gt; get (segments_ -&gt; size ( ) -1).y)
00409        != (segs.get (0).y ) )
00410     {
00411       cout &lt;&lt; <span class="stringliteral">"WARNING: Y values of last point of first envelope\n"</span>;
00412       cout &lt;&lt; <span class="stringliteral">"and first point of second envelope do not match.\n"</span>;
00413       cout &lt;&lt; <span class="stringliteral">"This implementation corrupts the first point of the\n"</span>;
00414       cout &lt;&lt; <span class="stringliteral">"second envelope\n"</span>;
00415     }
00416 
00417   <span class="comment">// for every element in the new collections</span>
00418   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 1; iIndex &lt; iNumSegments; iIndex++)
00419     {
00420       cout &lt;&lt; <span class="stringliteral">"***"</span> &lt;&lt; iIndex &lt;&lt; <span class="stringliteral">"***\n"</span>;
00421       <span class="comment">// add the current segment and point + 1 to our existing Collections</span>
00422       segTemp = segs.get(iIndex);
00423       segTemp.<a class="code" href="structenvelope__segment.html#o5">x</a> = segTemp.<a class="code" href="structenvelope__segment.html#o5">x</a> + x_Offset;
00424       segTemp.<a class="code" href="structenvelope__segment.html#o4">length</a> = segTemp.<a class="code" href="structenvelope__segment.html#o5">x</a> - x_Last;
00425       x_Last = segTemp.<a class="code" href="structenvelope__segment.html#o5">x</a>;
00426       segments_-&gt;add(segTemp);
00427     }
00428 }
00429 
00430 <span class="comment">//----------------------------------------------------------------------------//</span>
00431 <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a9">Envelope::AddToShape</a>
<a name="l00432"></a><a class="code" href="classEnvelope.html#a10">00432</a>     (<a class="code" href="classEnvelope.html">Envelope</a> * shape)
00433 {
00434   <span class="keywordflow">if</span> ( shape -&gt; segments_ == NULL )
00435     {
00436       cout &lt;&lt; <span class="stringliteral">"ERROR: Envelope to be added is undefined.\n"</span>;
00437       <span class="keywordflow">return</span>;
00438     }
00439 
00440     AddToShape ( * shape -&gt; segments_ );
00441 }
00442 
00443 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00444"></a><a class="code" href="classEnvelope.html#a11">00444</a> <a class="code" href="classEnvelope.html">Envelope</a>* <a class="code" href="classEnvelope.html#a11">Envelope::multiply</a>(<a class="code" href="classEnvelope.html">Envelope</a> &amp;env1, <a class="code" href="classEnvelope.html">Envelope</a> &amp;env2)
00445 {
00446   <span class="comment">// The multiplied envelopes are stretched or contracted to fit 0.0 to 1.0.</span>
00447 
00448   
00449   <a class="code" href="classEnvelope.html">Envelope</a> *tempenv1 = &amp;env1;
00450   <a class="code" href="classEnvelope.html">Envelope</a> *tempenv2 = &amp;env2;
00451   <a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a>* segments1_ = tempenv1-&gt;<a class="code" href="classEnvelope.html#a13">getSegments</a>();
00452   <a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a>* segments2_ = tempenv2-&gt;<a class="code" href="classEnvelope.html#a13">getSegments</a>();
00453 
00454   <span class="keywordtype">int</span> numSegs1 = segments1_ -&gt; size();
00455   <span class="keywordtype">int</span> numSegs2 = segments2_ -&gt; size();
00456   <span class="keywordtype">int</span> totalSegs;
00457     
00458     
00459   <span class="keywordflow">if</span> (numSegs1 &lt;= numSegs2)
00460     {
00461       totalSegs = numSegs1;
00462     }
00463   
00464   <span class="keywordflow">else</span> <span class="comment">//numSegs1 &gt; numSegs2</span>
00465     {
00466       totalSegs = numSegs2;
00467       <a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a>* temp = tempenv1-&gt;<a class="code" href="classEnvelope.html#a13">getSegments</a>();
00468       tempenv1 = &amp;env2;
00469       segments1_ = tempenv1-&gt;<a class="code" href="classEnvelope.html#a13">getSegments</a>();
00470       tempenv2 = &amp;env1;
00471       segments2_ = tempenv2-&gt;<a class="code" href="classEnvelope.html#a13">getSegments</a>();
00472       numSegs2 = numSegs1;
00473       numSegs1 = totalSegs;
00474     }
00475 
00476   <span class="keywordtype">float</span> envLength1 = segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(numSegs1-1).x;
00477   <span class="keywordtype">float</span> envLength2 = segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(numSegs2-1).x;
00478   
00479   <span class="comment">//This is basically a loop version of addPoint, so instead of adding one</span>
00480   <span class="comment">// point, multiple points are added.  This is also where the multiplication </span>
00481   <span class="comment">// of the y's occurs.  I went with the theory the shape of the envelope</span>
00482   <span class="comment">// was more important than the actual numbers.  To get the sizes right,</span>
00483   <span class="comment">// I divided the x coordinates by the length of the envelope, assuming</span>
00484   <span class="comment">// the envelope goes from 0.0 to (end).</span>
00485   <a class="code" href="structenvelope__segment.html">envelope_segment</a> seg;
00486   <a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a> stuffToReturn;
00487   <span class="keywordtype">int</span> othercounter = 0;
00488   <span class="keywordtype">int</span> choice;
00489 
00490 
00491   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; totalSegs; i++)
00492     {
00493       
00494       <span class="keywordtype">int</span> weirdi = i;
00495 
00496       <span class="keywordflow">if</span> (segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter).x == segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).x)
00497         { 
00498           seg.<a class="code" href="structenvelope__segment.html#o6">y</a> = (((segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).y))*((segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter).y)));
00499           seg.<a class="code" href="structenvelope__segment.html#o5">x</a> = (segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).x)/envLength1;
00500           choice = 1;
00501           <span class="comment">//othercounter++;</span>
00502         }
00503       
00504       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter).x)/envLength2) &gt; ((segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).x)/envLength1))
00505         { 
00506           choice = 2;
00507           seg.<a class="code" href="structenvelope__segment.html#o6">y</a> = (((segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).y))*(tempenv2-&gt;<a class="code" href="classEnvelope.html#a6">getValue</a>(((segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).x)/envLength1), 1))); 
00508           seg.<a class="code" href="structenvelope__segment.html#o5">x</a> = (segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).x)/envLength1;
00509         }
00510       <span class="keywordflow">else</span> <span class="comment">// if (((segments2_-&gt;get(othercounter).x)/envLength2) &gt; ((segments1_-&gt;get(i).x)/envLength1))</span>
00511         { 
00512           choice = 3;
00513           seg.<a class="code" href="structenvelope__segment.html#o6">y</a> = (((segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter).y))*(tempenv1-&gt;<a class="code" href="classEnvelope.html#a6">getValue</a>(((segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter).x)/envLength2), 1))); 
00514           seg.<a class="code" href="structenvelope__segment.html#o5">x</a> = (segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter).x)/envLength2;
00515           <span class="comment">//othercounter++;</span>
00516           i--;
00517           weirdi--;
00518         }
00519 
00520 
00521       
00522      
00523       <span class="keywordflow">if</span> ((i != totalSegs) || (othercounter != numSegs2))
00524         {
00525           seg.<a class="code" href="structenvelope__segment.html#o3">lengthType</a> = <a class="code" href="Types_8h.html#a12a8">FLEXIBLE</a>;
00526           
00527           <span class="keywordflow">if</span> ((i == 0) &amp;&amp; (othercounter != 0))
00528             i = 1;
00529 
00530 
00531           <span class="keywordflow">if</span> ((segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).interType == <a class="code" href="Types_8h.html#a13a9">EXPONENTIAL</a>) &amp;&amp; (segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter).interType == <a class="code" href="Types_8h.html#a13a11">LINEAR</a>))
00532             <span class="keywordflow">if</span> ((segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter).y) == (segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter+1).y))
00533               seg.<a class="code" href="structenvelope__segment.html#o0">interType</a> = <a class="code" href="Types_8h.html#a13a9">EXPONENTIAL</a>;
00534             <span class="keywordflow">else</span>
00535               seg.<a class="code" href="structenvelope__segment.html#o0">interType</a> = <a class="code" href="Types_8h.html#a13a10">CUBIC_SPLINE</a>;
00536              
00537           <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).interType == <a class="code" href="Types_8h.html#a13a11">LINEAR</a>) &amp;&amp; (segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter).interType == <a class="code" href="Types_8h.html#a13a11">LINEAR</a>))
00538             <span class="keywordflow">if</span> ((segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).y) != (segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i+1).y) )
00539               seg.<a class="code" href="structenvelope__segment.html#o0">interType</a> = <a class="code" href="Types_8h.html#a13a9">EXPONENTIAL</a>;
00540             <span class="keywordflow">else</span>
00541               seg.<a class="code" href="structenvelope__segment.html#o0">interType</a> = <a class="code" href="Types_8h.html#a13a11">LINEAR</a>;
00542 
00543           <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).interType == <a class="code" href="Types_8h.html#a13a11">LINEAR</a>) &amp;&amp; (segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter).interType == <a class="code" href="Types_8h.html#a13a11">LINEAR</a>))
00544             <span class="keywordflow">if</span> ( ((segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).y) == (segments1_-&gt;<a class="code" href="classCollection.html#a7">get</a>(i+1).y)) || ((segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter).y) == (segments2_-&gt;<a class="code" href="classCollection.html#a7">get</a>(othercounter+1).y))  ) 
00545               seg.<a class="code" href="structenvelope__segment.html#o0">interType</a> = <a class="code" href="Types_8h.html#a13a11">LINEAR</a>;
00546             <span class="keywordflow">else</span>
00547               seg.<a class="code" href="structenvelope__segment.html#o0">interType</a> = <a class="code" href="Types_8h.html#a13a9">EXPONENTIAL</a>;
00548 
00549           <span class="keywordflow">else</span><span class="comment">// if ((segments1_-&gt;get(i).interType != LINEAR) || (segments2_-&gt;get(othercounter).interType != LINEAR))                                                  </span>
00550             seg.<a class="code" href="structenvelope__segment.html#o0">interType</a> = <a class="code" href="Types_8h.html#a13a10">CUBIC_SPLINE</a>;  
00551         }
00552      
00553       <span class="keywordflow">if</span> ((choice == 1) || (choice == 3))
00554         othercounter++;
00555 
00556       <span class="keywordflow">if</span> ( i != weirdi)
00557         i = weirdi;
00558 
00559 
00560       stuffToReturn.<a class="code" href="classCollection.html#a4">add</a>(seg);
00561 
00562       <span class="keywordflow">if</span> (othercounter == numSegs2)
00563         {
00564           <span class="keywordflow">break</span>;
00565         }
00566     }
00567       
00568   <span class="keywordflow">return</span> (<span class="keyword">new</span> <a class="code" href="classEnvelope.html#a0">Envelope</a> (stuffToReturn)); <span class="comment">//HI-YO!!!</span>
00569 }
00570 
00571 
00572 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00573"></a><a class="code" href="classEnvelope.html#a12">00573</a> <a class="code" href="classCollection.html">Collection&lt;xy_point&gt;</a>* <a class="code" href="classEnvelope.html#a12">Envelope::getPoints</a> ()
00574 {
00575   <span class="comment">//extract point information out of the segments</span>
00576   <a class="code" href="classCollection.html">Collection&lt;xy_point&gt;</a>* points = <span class="keyword">new</span> <a class="code" href="classCollection.html">Collection&lt;xy_point&gt;</a>();
00577   <a class="code" href="structxy__point.html">xy_point</a> xy;
00578   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a10">size</a>(); i++)
00579   {
00580     xy.<a class="code" href="structxy__point.html#o0">x</a> = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).<a class="code" href="structenvelope__segment.html#o5">x</a>;
00581     xy.<a class="code" href="structxy__point.html#o1">y</a> = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(i).<a class="code" href="structenvelope__segment.html#o6">y</a>;
00582     points-&gt;<a class="code" href="classCollection.html#a4">add</a>(xy);
00583   }
00584   <span class="keywordflow">return</span> points;
00585 }
00586 
00587 
00588 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00589"></a><a class="code" href="classEnvelope.html#a13">00589</a> <a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a>* <a class="code" href="classEnvelope.html#a13">Envelope::getSegments</a> ()
00590 {
00591     <span class="comment">// the point data are stored in a member variable, so return a copy of it</span>
00592     <span class="keywordflow">return</span> (<span class="keyword">new</span> <a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a> (*segments_));
00593 }
00594 
00595 
00596 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00597"></a><a class="code" href="classEnvelope.html#a14">00597</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a14">Envelope::setSegment</a> (<span class="keywordtype">int</span> index, <a class="code" href="structenvelope__segment.html">envelope_segment</a> segment)
00598 {
00599   index++;
00600   <span class="keywordflow">if</span>(<a class="code" href="classEnvelope.html#d2">checkValidSegmentIndex</a>(index))
00601     {  
00602       <span class="keywordflow">if</span>(<a class="code" href="classEnvelope.html#d2">checkValidSegmentIndex</a>(index-1))
00603         {segment.<a class="code" href="structenvelope__segment.html#o4">length</a> = segment.<a class="code" href="structenvelope__segment.html#o5">x</a> - (<a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(index-1)).x;
00604         }
00605       <span class="keywordflow">else</span>
00606         segment.<a class="code" href="structenvelope__segment.html#o4">length</a> = segment.<a class="code" href="structenvelope__segment.html#o5">x</a>;
00607       <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a9">set</a>(index, segment);
00608     }
00609   <span class="keywordflow">else</span>
00610     cout &lt;&lt; <span class="stringliteral">"Invalid setSegment index!!!\n"</span>;
00611 }
00612 
00613 
00614 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00615"></a><a class="code" href="classEnvelope.html#a15">00615</a> <a class="code" href="structenvelope__segment.html">envelope_segment</a> <a class="code" href="classEnvelope.html#a15">Envelope::getSegment</a> (<span class="keywordtype">int</span> index)
00616 {
00617   index++;
00618   <span class="comment">// lets the Collection class hand an invalid index</span>
00619   <span class="keywordflow">return</span> <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(index);
00620 }
00621 
00622 
00623 <span class="comment">//----------------------------------------------------------------------------//</span>
00624 
<a name="l00625"></a><a class="code" href="classEnvelope.html#a16">00625</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a16">Envelope::setPoint</a> (<span class="keywordtype">int</span> index, <a class="code" href="structxy__point.html">xy_point</a> point)
00626 {
00627   <a class="code" href="structenvelope__segment.html">envelope_segment</a> seg;
00628   seg = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(index);  
00629   seg.<a class="code" href="structenvelope__segment.html#o5">x</a> = point.<a class="code" href="structxy__point.html#o0">x</a>;
00630   seg.<a class="code" href="structenvelope__segment.html#o6">y</a> = point.<a class="code" href="structxy__point.html#o1">y</a>;
00631   <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a9">set</a>(index, seg);
00632 }
00633 
00634 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00635"></a><a class="code" href="classEnvelope.html#a17">00635</a> <a class="code" href="structxy__point.html">xy_point</a> <a class="code" href="classEnvelope.html#a17">Envelope::getPoint</a> (<span class="keywordtype">int</span> index)
00636 {
00637   <span class="comment">//lets the Collection class hand an invalid index</span>
00638   <a class="code" href="structenvelope__segment.html">envelope_segment</a> tempseg;
00639   <a class="code" href="structxy__point.html">xy_point</a> pt;
00640   tempseg = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(index);
00641   pt.<a class="code" href="structxy__point.html#o0">x</a> = tempseg.<a class="code" href="structenvelope__segment.html#o5">x</a>; pt.<a class="code" href="structxy__point.html#o1">y</a> = tempseg.<a class="code" href="structenvelope__segment.html#o6">y</a>;
00642   <span class="keywordflow">return</span> pt;
00643 }
00644 
00645 
00646 <span class="comment">//----------------------------------------------------------------------------//</span>
00647 
<a name="l00648"></a><a class="code" href="classEnvelope.html#a19">00648</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a19">Envelope::addSegment</a> (<a class="code" href="structenvelope__segment.html">envelope_segment</a> segment)
00649 {
00650   <span class="comment">//make sure it is an addable segment</span>
00651   segment.<a class="code" href="structenvelope__segment.html#o4">length</a> = segment.<a class="code" href="structenvelope__segment.html#o5">x</a> - <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(<a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a10">size</a>()-1).<a class="code" href="structenvelope__segment.html#o5">x</a>;
00652   <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a4">add</a>(segment);
00653 }
00654 
00655 
00656 
00657 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00658"></a><a class="code" href="classEnvelope.html#a18">00658</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a18">Envelope::addPoint</a> (<a class="code" href="structxy__point.html">xy_point</a> point)
00659 {
00660   <a class="code" href="structenvelope__segment.html">envelope_segment</a> seg;
00661   seg.<a class="code" href="structenvelope__segment.html#o5">x</a> = point.<a class="code" href="structxy__point.html#o0">x</a>; seg.<a class="code" href="structenvelope__segment.html#o6">y</a> = point.<a class="code" href="structxy__point.html#o1">y</a>;
00662   seg.<a class="code" href="structenvelope__segment.html#o3">lengthType</a> = <a class="code" href="Types_8h.html#a12a7">FIXED</a>;
00663   seg.<a class="code" href="structenvelope__segment.html#o0">interType</a> = <a class="code" href="Types_8h.html#a13a11">LINEAR</a>;
00664   <a class="code" href="classEnvelope.html#a19">addSegment</a>(seg);
00665 }
00666 
00667 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00668"></a><a class="code" href="classEnvelope.html#a20">00668</a> <a class="code" href="Types_8h.html#a3">m_value_type</a> <a class="code" href="classEnvelope.html#a20">Envelope::getSegmentLength</a> (<span class="keywordtype">int</span> index)
00669 {
00670   index++;
00671   <span class="comment">// lets the Collection class hand an invalid index</span>
00672   <span class="keywordflow">return</span> (<a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(index).<a class="code" href="structenvelope__segment.html#o4">length</a>);
00673 }
00674 
00675 
00676 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00677"></a><a class="code" href="classEnvelope.html#a21">00677</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a21">Envelope::setSegmentLength</a> (<span class="keywordtype">int</span> index, <a class="code" href="Types_8h.html#a3">m_value_type</a> length)
00678 {
00679   index++;
00680   <span class="comment">// make sure the time is positive, otherwise bad things will happen</span>
00681   <span class="keywordflow">if</span> (length &lt; 0)
00682     {
00683       length = -length;
00684     }
00685   
00686   <span class="comment">// assumes a valid index is supplied</span>
00687   <a class="code" href="structenvelope__segment.html">envelope_segment</a> segTemp = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a> (index);
00688   segTemp.<a class="code" href="structenvelope__segment.html#o4">length</a> = length;
00689   <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a9">set</a> (index, segTemp);
00690 }
00691 
00692 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00693"></a><a class="code" href="classEnvelope.html#a22">00693</a> <a class="code" href="Types_8h.html#a12">stretch_type</a> <a class="code" href="classEnvelope.html#a22">Envelope::getSegmentLengthType</a> (<span class="keywordtype">int</span> index)
00694 {
00695   index++;
00696   <span class="comment">// assumes a valid index is supplied</span>
00697   <span class="keywordflow">return</span> (<a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(index).<a class="code" href="structenvelope__segment.html#o3">lengthType</a>);
00698 }
00699 
00700 
00701 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00702"></a><a class="code" href="classEnvelope.html#a23">00702</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a23">Envelope::setSegmentLengthType</a> (<span class="keywordtype">int</span> index, stretch_type lengthType)
00703 {
00704   index++;
00705   <span class="comment">// assumes a valid index is supplied</span>
00706   <a class="code" href="structenvelope__segment.html">envelope_segment</a> segTemp = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a> (index);
00707   segTemp.<a class="code" href="structenvelope__segment.html#o3">lengthType</a> = lengthType;
00708   <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a9">set</a> (index, segTemp);
00709 }
00710 
00711 
00712 <span class="comment">//----------------------------------------------------------------------------//</span>
00713 <a class="code" href="Types_8h.html#a13">interpolation_type</a> <a class="code" href="classEnvelope.html#a24">Envelope::getSegmentInterpolationType</a>
<a name="l00714"></a><a class="code" href="classEnvelope.html#a24">00714</a>                                             (<span class="keywordtype">int</span> index)
00715 {
00716   index++;
00717   <span class="comment">// assumes a valid index is supplied</span>
00718   <span class="keywordflow">return</span> (segments_-&gt;get(index).interType);
00719 }
00720 
00721 
00722 <span class="comment">//----------------------------------------------------------------------------//</span>
00723 <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a25">Envelope::setSegmentInterpolationType</a>
<a name="l00724"></a><a class="code" href="classEnvelope.html#a25">00724</a>                               (<span class="keywordtype">int</span> index,
00725                                <a class="code" href="Types_8h.html#a13">interpolation_type</a> interType)
00726 {
00727   index++;
00728   <span class="comment">// assumes a valid index is supplied</span>
00729   <a class="code" href="structenvelope__segment.html">envelope_segment</a> segTemp = segments_-&gt;get (index);
00730   segTemp.<a class="code" href="structenvelope__segment.html#o0">interType</a> = interType;
00731   segments_-&gt;set (index, segTemp);
00732 }
00733 
00734 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00735"></a><a class="code" href="classEnvelope.html#d2">00735</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classEnvelope.html#d2">Envelope::checkValidSegmentIndex</a> (<span class="keywordtype">int</span> index)
00736 {
00737     <span class="comment">// check if index is valid</span>
00738     <span class="keywordflow">return</span> ((index &gt;= 0) &amp;&amp; (<a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a10">size</a>() &gt; index));
00739 }
00740 
00741     
00742 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00743"></a><a class="code" href="classEnvelope.html#a26">00743</a> <a class="code" href="classIterator.html">Iterator&lt;m_value_type&gt;</a> <a class="code" href="classEnvelope.html#a26">Envelope::valueIterator</a>()
00744 {
00745     <span class="comment">// optimize so that if the envelope is used repeatedly without changing</span>
00746     <span class="comment">// the time value that is assigned, interpolators are not re-created</span>
00747     <span class="comment">// every time</span>
00748     <span class="keywordflow">if</span> (<a class="code" href="classEnvelope.html#r3">totalLength_</a> != this-&gt;<a class="code" href="classDynamicVariable.html#a7">getDuration</a>()
00749         || <a class="code" href="classEnvelope.html#r4">currentInterpolatorRate_</a> != this-&gt;<a class="code" href="classDynamicVariable.html#a9">getSamplingRate</a>())
00750     {
00751         <a class="code" href="classEnvelope.html#r3">totalLength_</a> = this-&gt;<a class="code" href="classDynamicVariable.html#a7">getDuration</a>();
00752         <a class="code" href="classEnvelope.html#r4">currentInterpolatorRate_</a> = this-&gt;<a class="code" href="classDynamicVariable.html#a9">getSamplingRate</a>();
00753         <span class="comment">// populate the lengths member variable</span>
00754         <a class="code" href="classEnvelope.html#d1">generateLengths</a>(<a class="code" href="classEnvelope.html#r3">totalLength_</a>);
00755 
00756         <span class="comment">// populate the interpolator member variable with interpolators, based</span>
00757         <span class="comment">// on the lengths just set</span>
00758         <a class="code" href="classEnvelope.html#d0">addInterpolators</a>(<a class="code" href="classEnvelope.html#r4">currentInterpolatorRate_</a>);
00759     }
00760 
00761     <span class="comment">// give them the big iterator</span>
00762     <span class="keywordflow">return</span> (<a class="code" href="classIterator.html">Iterator&lt;m_value_type&gt;</a>
00763                 (<span class="keyword">new</span> <a class="code" href="classEnvelopeIterator.html">EnvelopeIterator</a>(*<a class="code" href="classEnvelope.html#r1">interpolators_</a>)));
00764 }
00765 
00766 
00767 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00768"></a><a class="code" href="classEnvelope.html#d1">00768</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#d1">Envelope::generateLengths</a> (<a class="code" href="Types_8h.html#a2">m_time_type</a> totalLength)
00769 {
00770 <span class="preprocessor">#ifdef DEBUG_MODE</span>
00771 <span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">"Envelope::generateLengths"</span> &lt;&lt; endl;
00772 <span class="preprocessor">#endif</span>
00773 <span class="preprocessor"></span>    <span class="keywordtype">int</span> iNumSegments = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a10">size</a>()-1;
00774     <span class="keywordtype">double</span> dTotalFixedLength = 0;
00775     <span class="keywordtype">double</span> dTotalFlexPercent = 0;
00776     <span class="keywordtype">double</span> dScaleRatio = 1;
00777 
00778     <a class="code" href="classEnvelope.html#r3">totalLength_</a> = totalLength;
00779 
00780     <span class="comment">// get rid of previously generated lengths and make a new collection</span>
00781     <span class="keywordflow">if</span> (<a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a> != NULL)
00782     {
00783         <span class="keyword">delete</span> (<a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>);
00784     }
00785     <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a> = <span class="keyword">new</span> <a class="code" href="classCollection.html">Collection&lt;m_value_type&gt;</a> ();
00786 
00787     <span class="comment">// figure out how they want to allocate length for each segment and populate</span>
00788     <span class="comment">// the generated lengths with their current values</span>
00789     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; iNumSegments; iIndex++)
00790     {
00791         <span class="comment">// if this segment has fixed-length, increment fixed length running total</span>
00792         <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classEnvelope.html#a22">getSegmentLengthType</a>(iIndex) == <a class="code" href="Types_8h.html#a12a7">FIXED</a>)
00793         {
00794             dTotalFixedLength += this-&gt;<a class="code" href="classEnvelope.html#a20">getSegmentLength</a>(iIndex);
00795         }
00796         <span class="comment">// else increment flex-length running total</span>
00797         <span class="keywordflow">else</span>
00798         {
00799             dTotalFlexPercent += this-&gt;<a class="code" href="classEnvelope.html#a20">getSegmentLength</a>(iIndex);
00800         }
00801         <span class="comment">// append their current value to our values for generated lengths</span>
00802         <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a4">add</a>(this-&gt;getSegmentLength(iIndex));
00803     }
00804 
00805     <span class="comment">// now, correct the generated values as necessary (i.e. the rest of this)</span>
00806 
00807     <span class="comment">// if they specified more FIXED length than actual length, or if there is no</span>
00808     <span class="comment">// FIEXIBLE length and they did not specify enough FIXED length, scale the</span>
00809     <span class="comment">// FIXED lengths to the actual length (and set total amount of FLEXIBLE length</span>
00810     <span class="comment">// to zero)</span>
00811     <span class="keywordflow">if</span> (dTotalFixedLength &gt; <a class="code" href="classEnvelope.html#r3">totalLength_</a>
00812         || (dTotalFixedLength &lt; <a class="code" href="classEnvelope.html#r3">totalLength_</a> &amp;&amp; dTotalFlexPercent == 0))
00813     {
00814       <span class="keywordflow">if</span>(dTotalFixedLength &gt; <a class="code" href="classEnvelope.html#r3">totalLength_</a>)
00815         cout &lt;&lt; <span class="stringliteral">"WARNING: Duration specified was less than added FIXED lengths\n"</span>
00816            &lt;&lt; <span class="stringliteral">"FIXED lengths will also be scaled down\n"</span>;
00817       <span class="keywordflow">else</span>
00818         cout &lt;&lt; <span class="stringliteral">"WARNING: Duration specified was more than added FIXED lengths\n"</span>
00819              &lt;&lt; <span class="stringliteral">"Since no lengths are FLEXIBLE, FIXED lengths will be scaled up\n"</span>;
00820         <span class="comment">// no flexible length is available</span>
00821         dTotalFlexPercent = 0;
00822 
00823         <span class="comment">// get a ratio to scale all fixed length entries by</span>
00824         dScaleRatio = <a class="code" href="classEnvelope.html#r3">totalLength_</a> / dTotalFixedLength;
00825 
00826 <span class="preprocessor">#ifdef DEBUG_MODE</span>
00827 <span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">"Envelope::generateLengths FIXED dScaleRatio = "</span> &lt;&lt; dScaleRatio &lt;&lt; endl;
00828 <span class="preprocessor">#endif</span>
00829 <span class="preprocessor"></span>
00830         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; iNumSegments; iIndex++)
00831         {
00832             <span class="comment">// scale every FIXED length value</span>
00833             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classEnvelope.html#a22">getSegmentLengthType</a>(iIndex) == <a class="code" href="Types_8h.html#a12a7">FIXED</a>)
00834             {
00835                 <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a9">set</a>
00836                     (iIndex,
00837                      this-&gt;<a class="code" href="classEnvelope.html#a20">getSegmentLength</a>(iIndex) * dScaleRatio);
00838                 this-&gt;<a class="code" href="classEnvelope.html#a21">setSegmentLength</a>(iIndex, 
00839                                        this-&gt;getSegmentLength(iIndex) * dScaleRatio);
00840             }
00841             <span class="keywordflow">else</span>
00842             {
00843                 <span class="comment">// all flex length entries are set to 0</span>
00844                 <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a9">set</a> (iIndex, 0);
00845                 this-&gt;<a class="code" href="classEnvelope.html#a21">setSegmentLength</a>(iIndex, 0);
00846             }
00847         }
00848     }
00849     <span class="comment">// else if their percentages do not add up to 100% (i.e. 1.0) and they are</span>
00850     <span class="comment">// trying to use flex length, scale the flex length values</span>
00851     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dTotalFlexPercent != 1.0 &amp;&amp; dTotalFlexPercent != 0)
00852     {
00853         dScaleRatio = 1.0 / dTotalFlexPercent;
00854 
00855 <span class="preprocessor">#ifdef DEBUG_MODE</span>
00856 <span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">"Envelope::generateLengths FLEXIBLE dScaleRatio = "</span> &lt;&lt; dScaleRatio &lt;&lt; endl;
00857 <span class="preprocessor">#endif</span>
00858 <span class="preprocessor"></span>
00859         <span class="comment">// scale percentages</span>
00860         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; iNumSegments; iIndex++)
00861         {
00862             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classEnvelope.html#a22">getSegmentLengthType</a>(iIndex) == <a class="code" href="Types_8h.html#a12a8">FLEXIBLE</a>)
00863             {
00864                 <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a9">set</a>
00865                     (iIndex,
00866                      this-&gt;<a class="code" href="classEnvelope.html#a20">getSegmentLength</a>(iIndex) * dScaleRatio);
00867             }
00868         }
00869     }
00870 
00871         
00872     <span class="comment">// if we have FLEXIBLE length to set, the values stored right now are only</span>
00873     <span class="comment">// ratios of length available, so we need to set them to actual lengths</span>
00874     <span class="keywordflow">if</span> (dTotalFlexPercent &gt; 0)
00875     {
00876         <span class="comment">// calculate the length available to use for flex durations</span>
00877         <span class="keywordtype">double</span> flexLengthAvailable = <a class="code" href="classEnvelope.html#r3">totalLength_</a> - dTotalFixedLength;
00878 
00879 <span class="preprocessor">#ifdef DEBUG_MODE</span>
00880 <span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">"Envelope::generateLengths flexLengthAvailable = "</span> &lt;&lt; flexLengthAvailable &lt;&lt; endl;
00881 <span class="preprocessor">#endif</span>
00882 <span class="preprocessor"></span>
00883         <span class="comment">// set actual durations for FLEXIBLE length segments</span>
00884         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; iNumSegments; iIndex++)
00885         {
00886             <span class="comment">// if this is a flex-length entry, set length accordingly</span>
00887             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classEnvelope.html#a22">getSegmentLengthType</a>(iIndex) == <a class="code" href="Types_8h.html#a12a8">FLEXIBLE</a>)
00888             {
00889               <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a9">set</a>
00890                 (iIndex,
00891                  <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex) * flexLengthAvailable);
00892             }
00893         }
00894     }
00895         
00896 
00897 <span class="preprocessor">#ifdef DEBUG_MODE</span>
00898 <span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">"Envelope::generateLengths all done.  Segments lengths are:"</span> &lt;&lt; endl;
00899 
00900     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; iNumSegments; iIndex++)
00901     {
00902         cout &lt;&lt; <span class="stringliteral">"Segment "</span> &lt;&lt; iIndex &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex) &lt;&lt; endl;
00903     }
00904 <span class="preprocessor">#endif</span>
00905 <span class="preprocessor"></span>}
00906 
00907 
00908 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00909"></a><a class="code" href="classEnvelope.html#d0">00909</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#d0">Envelope::addInterpolators</a> (<a class="code" href="Types_8h.html#a4">m_rate_type</a> rate)
00910 {
00911 <span class="preprocessor">#ifdef DEBUG_MODE</span>
00912 <span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">"Envelope::addInterpolators"</span> &lt;&lt; endl;
00913     cout &lt;&lt; <span class="stringliteral">"num segments: "</span> &lt;&lt; <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a10">size</a>() &lt;&lt; endl;
00914     <span class="comment">//    cout &lt;&lt; "num points: " &lt;&lt; xyPoints_-&gt;size() &lt;&lt; endl;</span>
00915 <span class="preprocessor">#endif</span>
00916 <span class="preprocessor"></span>
00917     <span class="keywordtype">int</span> iNumSegments = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a10">size</a>();
00918 
00919     <span class="comment">// clear out interpolators that are stored, if there are any stored</span>
00920     <span class="keywordflow">if</span> (<a class="code" href="classEnvelope.html#r1">interpolators_</a> != NULL)
00921     {
00922         <span class="keyword">delete</span> (<a class="code" href="classEnvelope.html#r1">interpolators_</a>);
00923     }
00924 
00925     <span class="comment">// initialize a new Collection for interpolators</span>
00926     <a class="code" href="classEnvelope.html#r1">interpolators_</a> = <span class="keyword">new</span> <a class="code" href="classCollection.html">Collection&lt;Interpolator*&gt;</a> ();
00927     <a class="code" href="Types_8h.html#a3">m_value_type</a> prev = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(0).<a class="code" href="structenvelope__segment.html#o6">y</a>;
00928     <span class="comment">// for each segment that we have, store a new interpolator</span>
00929     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; iNumSegments-1; iIndex++)
00930     {
00931         <span class="comment">// add an interpolator for the current segment to the Collection</span>
00932         <span class="keywordflow">switch</span> (<a class="code" href="classEnvelope.html#a24">getSegmentInterpolationType</a>(iIndex))
00933           {
00934           <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a13a9">EXPONENTIAL</a>:
00935             <a class="code" href="classEnvelope.html#r1">interpolators_</a>-&gt;<a class="code" href="classCollection.html#a4">add</a>(<span class="keyword">new</span> <a class="code" href="classExponentialInterpolator.html">ExponentialInterpolator</a>());
00936             <span class="keywordflow">break</span>;
00937             
00938           <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a13a10">CUBIC_SPLINE</a>:
00939             <a class="code" href="classEnvelope.html#r1">interpolators_</a>-&gt;<a class="code" href="classCollection.html#a4">add</a>(<span class="keyword">new</span> <a class="code" href="classCubicSplineInterpolator.html">CubicSplineInterpolator</a>());
00940             <span class="keywordflow">break</span>;
00941             
00942           <span class="keywordflow">default</span>: 
00943             <a class="code" href="classEnvelope.html#r1">interpolators_</a>-&gt;<a class="code" href="classCollection.html#a4">add</a>(<span class="keyword">new</span> <a class="code" href="classLinearInterpolator.html">LinearInterpolator</a>());
00944             <span class="keywordflow">break</span>;
00945         }
00946         <span class="comment">// set the Interpolator's sampling rate to the rate specified</span>
00947         <a class="code" href="classEnvelope.html#r1">interpolators_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex)-&gt;<a class="code" href="classDynamicVariable.html#a8">setSamplingRate</a>(rate);
00948         <a class="code" href="Types_8h.html#a3">m_value_type</a> tempLengthValue = <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex);
00949 
00950         <span class="comment">// add a start and end point to this interpolator:</span>
00951         <a class="code" href="classEnvelope.html#r1">interpolators_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex)-&gt;<a class="code" href="classInterpolator.html#a2">addEntry</a>(0, prev);
00952         <a class="code" href="classEnvelope.html#r1">interpolators_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex)-&gt;<a class="code" href="classInterpolator.html#a2">addEntry</a>
00953           (tempLengthValue,
00954                      <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex+1).<a class="code" href="structenvelope__segment.html#o6">y</a>);
00955 
00956 
00957         <span class="comment">// set interpolator duration</span>
00958         <a class="code" href="classEnvelope.html#r1">interpolators_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex)-&gt;<a class="code" href="classDynamicVariable.html#a6">setDuration</a>(tempLengthValue);
00959         prev = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex+1).<a class="code" href="structenvelope__segment.html#o6">y</a>;
00960 
00961 <span class="preprocessor">#ifdef DEBUG_MODE</span>
00962 <span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">"Interpolator #"</span> &lt;&lt; iIndex &lt;&lt; <span class="stringliteral">" - added points: "</span> &lt;&lt; endl;
00963     cout &lt;&lt; <span class="stringliteral">"   (0, "</span> &lt;&lt; xyPoints_-&gt;get(iIndex).y &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl;
00964     cout &lt;&lt; <span class="stringliteral">"   ("</span> &lt;&lt; <a class="code" href="classEnvelope.html#r2">generatedSegmentLengths_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex) &lt;&lt; <span class="stringliteral">", "</span>;
00965     cout &lt;&lt; xyPoints_-&gt;get(iIndex + 1).y &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl;
00966 <span class="preprocessor">#endif</span>
00967 <span class="preprocessor"></span>    }
00968 }
00969 
00970 
00971 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00972"></a><a class="code" href="classEnvelope.html#a27">00972</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a27">Envelope::scale</a>(<a class="code" href="Types_8h.html#a3">m_value_type</a> factor)
00973 {
00974     <span class="keywordtype">int</span> iNumSegments = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a10">size</a>();
00975     <a class="code" href="structenvelope__segment.html">envelope_segment</a> segTemp;
00976 
00977     <span class="comment">// for every point that we've got stored</span>
00978     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; iNumSegments; iIndex++)
00979     {
00980         <span class="comment">// scale this value by the factor given</span>
00981         segTemp = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex);
00982         segTemp.<a class="code" href="structenvelope__segment.html#o6">y</a> *= factor;
00983         <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a9">set</a>(iIndex, segTemp);
00984     }
00985 }
00986     
00987      
00988 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l00989"></a><a class="code" href="classEnvelope.html#a28">00989</a> <a class="code" href="Types_8h.html#a3">m_value_type</a> <a class="code" href="classEnvelope.html#a28">Envelope::getMaxValue</a>()
00990 {
00991     <span class="keywordtype">int</span> iNumSegments = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a10">size</a>();
00992     <a class="code" href="Types_8h.html#a3">m_value_type</a> maxVal = 0.0;
00993 
00994     <span class="comment">// for every point that we've got stored</span>
00995     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; iNumSegments; iIndex++)
00996     {
00997         <span class="comment">// if this point's value is greater than the max, set max = this value</span>
00998         <span class="keywordflow">if</span> (<a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex).<a class="code" href="structenvelope__segment.html#o6">y</a> &gt; maxVal)
00999         {
01000             maxVal = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a7">get</a>(iIndex).<a class="code" href="structenvelope__segment.html#o6">y</a>;
01001         }
01002     }
01003 
01004     <span class="keywordflow">return</span> maxVal;
01005 }
01006 
01007 
01008 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l01009"></a><a class="code" href="classEnvelope.html#a30">01009</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a29">Envelope::xml_print</a>( ofstream&amp; xmlOutput )
01010 {
01011         <a class="code" href="classDynamicVariable.html">DynamicVariable</a>* pnt2dyn = <span class="keyword">this</span>;
01012 
01013         xmlOutput &lt;&lt; <span class="stringliteral">"&lt;dv id=\""</span> &lt;&lt; (<span class="keywordtype">long</span>)pnt2dyn &lt;&lt; <span class="stringliteral">"\"&gt;"</span> &lt;&lt; endl;
01014         xmlOutput &lt;&lt; <span class="stringliteral">"\t&lt;dv_type value=\"envelope\" /&gt;"</span> &lt;&lt; endl;
01015         xmlOutput &lt;&lt; <span class="stringliteral">"\t&lt;duration value=\""</span> &lt;&lt; <a class="code" href="classDynamicVariable.html#a7">getDuration</a>() &lt;&lt; <span class="stringliteral">"\" /&gt;"</span> &lt;&lt; endl;
01016         xmlOutput &lt;&lt; <span class="stringliteral">"\t&lt;rate value=\""</span> &lt;&lt; <a class="code" href="classDynamicVariable.html#a9">getSamplingRate</a>() &lt;&lt; <span class="stringliteral">"\" /&gt;"</span> &lt;&lt; endl;
01017 
01018         <span class="comment">//Print out private vars and collections for Envelope here</span>
01019         xmlOutput &lt;&lt; <span class="stringliteral">"\t&lt;totalLength value=\""</span> &lt;&lt; <a class="code" href="classEnvelope.html#r3">totalLength_</a> &lt;&lt; <span class="stringliteral">"\" /&gt;"</span> &lt;&lt; endl;
01020         xmlOutput &lt;&lt; <span class="stringliteral">"\t&lt;currentInterpolatorRate value=\""</span> &lt;&lt; <a class="code" href="classEnvelope.html#r4">currentInterpolatorRate_</a> &lt;&lt; <span class="stringliteral">"\" /&gt;"</span> &lt;&lt; endl;
01021         <a class="code" href="structenvelope__segment.html">envelope_segment</a> myseg;
01022 
01023         <a class="code" href="classIterator.html">Iterator&lt;envelope_segment&gt;</a> it_segments = <a class="code" href="classEnvelope.html#r0">segments_</a>-&gt;<a class="code" href="classCollection.html#a12">iterator</a>();
01024         <span class="keywordflow">while</span>(it_segments.<a class="code" href="classIterator.html#a4">hasNext</a>())
01025         {
01026                 myseg = it_segments.<a class="code" href="classIterator.html#a5">next</a>();
01027                 xmlOutput &lt;&lt; <span class="stringliteral">"\t&lt;segment&gt;"</span> &lt;&lt; endl;
01028                         xmlOutput &lt;&lt; <span class="stringliteral">"\t\t&lt;type value=\""</span>;
01029                         <span class="keywordflow">switch</span>(myseg.<a class="code" href="structenvelope__segment.html#o0">interType</a>)
01030                         {
01031                                 <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a13a11">LINEAR</a>:
01032                                         xmlOutput &lt;&lt; <span class="stringliteral">"LINEAR"</span>;
01033                                         <span class="keywordflow">break</span>;
01034                                 <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a13a9">EXPONENTIAL</a>:
01035                                         xmlOutput &lt;&lt; <span class="stringliteral">"EXPONENTIAL"</span>;
01036                                         <span class="keywordflow">break</span>;
01037                                 <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a13a10">CUBIC_SPLINE</a>:
01038                                         xmlOutput &lt;&lt; <span class="stringliteral">"CUBIC_SPLINE"</span>;
01039                                         <span class="keywordflow">break</span>;
01040                         }
01041                         xmlOutput &lt;&lt; <span class="stringliteral">"\" /&gt;"</span> &lt;&lt; endl;
01042                         
01043                         xmlOutput &lt;&lt; <span class="stringliteral">"\t\t&lt;length type=\""</span>;
01044                         <span class="keywordflow">switch</span> (myseg.<a class="code" href="structenvelope__segment.html#o3">lengthType</a>)
01045                         {
01046                                 <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a12a7">FIXED</a>:
01047                                         xmlOutput &lt;&lt; <span class="stringliteral">"FIXED"</span>;
01048                                         <span class="keywordflow">break</span>;
01049                                 <span class="keywordflow">case</span> <a class="code" href="Types_8h.html#a12a8">FLEXIBLE</a>:
01050                                         xmlOutput &lt;&lt; <span class="stringliteral">"FLEXIBLE"</span>;
01051                                         <span class="keywordflow">break</span>;
01052                         }
01053                         xmlOutput &lt;&lt; <span class="stringliteral">"\" value=\""</span> &lt;&lt; myseg.<a class="code" href="structenvelope__segment.html#o4">length</a> &lt;&lt; <span class="stringliteral">"\" /&gt;"</span> &lt;&lt; endl;
01054                         
01055                         xmlOutput &lt;&lt; <span class="stringliteral">"\t\t&lt;xyPoint x=\""</span> &lt;&lt; myseg.<a class="code" href="structenvelope__segment.html#o5">x</a> &lt;&lt; <span class="stringliteral">"\" "</span>;
01056                         xmlOutput &lt;&lt; <span class="stringliteral">"y=\""</span> &lt;&lt; myseg.<a class="code" href="structenvelope__segment.html#o6">y</a> &lt;&lt; <span class="stringliteral">"\" /&gt;"</span> &lt;&lt; endl;
01057                 xmlOutput &lt;&lt; <span class="stringliteral">"\t&lt;/segment&gt;"</span> &lt;&lt; endl;
01058         }
01059         <span class="comment">//Note: the interpolators_ and generatedSegmentLengths_ collections</span>
01060         <span class="comment">//      doesn't need to be backed up; it is used for internal</span>
01061         <span class="comment">//      optimization only, not storing data</span>
01062 
01063         xmlOutput &lt;&lt; <span class="stringliteral">"&lt;/dv&gt;"</span> &lt;&lt; endl;
01064 
01065 }
01066 
01067 <span class="comment">//----------------------------------------------------------------------------//</span>
<a name="l01068"></a><a class="code" href="classEnvelope.html#a29">01068</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a29">Envelope::xml_print</a>( ofstream&amp; xmlOutput, list&lt;DynamicVariable*&gt;&amp; dynObjs )
01069 {
01070         <a class="code" href="classDynamicVariable.html">DynamicVariable</a>* pnt2dyn = <span class="keyword">this</span>;
01071 
01072         <span class="comment">//Print the pointer value as an ID, then the "meat" gets printed later</span>
01073         xmlOutput &lt;&lt; <span class="stringliteral">"\t\t\t\t&lt;dv_type value=\"envelope\" /&gt;"</span> &lt;&lt; endl;
01074         xmlOutput &lt;&lt; <span class="stringliteral">"\t\t\t\t&lt;dv_ptr id=\""</span> &lt;&lt; (<span class="keywordtype">long</span>)pnt2dyn &lt;&lt; <span class="stringliteral">"\" /&gt;"</span> &lt;&lt; endl;
01075 
01076         <span class="comment">// Update dynamic variable list if necessary</span>
01077         list&lt;DynamicVariable*&gt;::const_iterator dynit;
01078         <span class="keywordflow">for</span>( dynit=dynObjs.begin(); dynit != dynObjs.end(); dynit++ )
01079         {
01080                 <span class="keywordflow">if</span>( (*dynit) == <span class="keyword">this</span> )
01081                         <span class="keywordflow">break</span>;
01082         }
01083         <span class="keywordflow">if</span>( dynit == dynObjs.end() ){
01084                 dynObjs.push_back( <span class="keyword">this</span> );
01085         }
01086 
01087 }
01088 
<a name="l01089"></a><a class="code" href="classEnvelope.html#a31">01089</a> <span class="keywordtype">void</span> <a class="code" href="classEnvelope.html#a31">Envelope::xml_read</a>(<a class="code" href="classXmlReader_1_1xmltag.html">XmlReader::xmltag</a>* envtag)
01090 {
01091         <span class="keywordtype">char</span> *value;
01092 
01093         <a class="code" href="classCollection.html">Collection&lt;envelope_segment&gt;</a> segmentCollection;
01094         <a class="code" href="structenvelope__segment.html">envelope_segment</a> seg;
01095         
01096         <span class="keywordflow">if</span>(value=envtag-&gt;<a class="code" href="classXmlReader_1_1xmltag.html#a5">findChildParamValue</a>(<span class="stringliteral">"duration"</span>,<span class="stringliteral">"value"</span>))
01097         {
01098                 <a class="code" href="classDynamicVariable.html#a6">setDuration</a>(atof(value));
01099         }
01100         
01101         <span class="keywordflow">if</span>(value=envtag-&gt;<a class="code" href="classXmlReader_1_1xmltag.html#a5">findChildParamValue</a>(<span class="stringliteral">"rate"</span>,<span class="stringliteral">"value"</span>))
01102         {
01103                 <a class="code" href="classDynamicVariable.html#a8">setSamplingRate</a>(atoi(value));
01104         }
01105         
01106         <a class="code" href="classXmlReader_1_1xmltag.html">XmlReader::xmltag</a> *segtag;
01107         <span class="keywordflow">while</span>(segtag=envtag-&gt;<a class="code" href="classXmlReader_1_1xmltag.html#o3">children</a>-&gt;find(<span class="stringliteral">"segment"</span>))
01108         {
01109                 <a class="code" href="classXmlReader_1_1xmltag.html">XmlReader::xmltag</a> *xy = segtag-&gt;<a class="code" href="classXmlReader_1_1xmltag.html#o3">children</a>-&gt;find(<span class="stringliteral">"xyPoint"</span>);
01110                 <span class="keywordflow">if</span>(value=xy-&gt;<a class="code" href="classXmlReader_1_1xmltag.html#a3">getParamValue</a>(<span class="stringliteral">"x"</span>))
01111                 {
01112                         seg.<a class="code" href="structenvelope__segment.html#o5">x</a> = atof(value);
01113                 }
01114                 <span class="keywordflow">if</span>(value=xy-&gt;<a class="code" href="classXmlReader_1_1xmltag.html#a3">getParamValue</a>(<span class="stringliteral">"y"</span>))
01115                 {
01116                         seg.<a class="code" href="structenvelope__segment.html#o6">y</a> = atof(value);
01117                 }
01118                 <span class="keywordflow">if</span>(value=segtag-&gt;<a class="code" href="classXmlReader_1_1xmltag.html#a5">findChildParamValue</a>(<span class="stringliteral">"type"</span>,<span class="stringliteral">"value"</span>))
01119                 {
01120                         <span class="keywordflow">if</span>(strcmp(value, <span class="stringliteral">"LINEAR"</span>) == 0)
01121                                 seg.<a class="code" href="structenvelope__segment.html#o0">interType</a> = <a class="code" href="Types_8h.html#a13a11">LINEAR</a>;
01122                         <span class="keywordflow">if</span>(strcmp(value, <span class="stringliteral">"EXPONENTIAL"</span>) == 0)
01123                                 seg.<a class="code" href="structenvelope__segment.html#o0">interType</a> = <a class="code" href="Types_8h.html#a13a9">EXPONENTIAL</a>;
01124                         <span class="keywordflow">if</span>(strcmp(value, <span class="stringliteral">"CUBIC_SPLINE"</span>) == 0)
01125                                 seg.<a class="code" href="structenvelope__segment.html#o0">interType</a> = <a class="code" href="Types_8h.html#a13a10">CUBIC_SPLINE</a>;
01126                 }
01127                 <span class="keywordflow">if</span>(value=segtag-&gt;<a class="code" href="classXmlReader_1_1xmltag.html#a5">findChildParamValue</a>(<span class="stringliteral">"length"</span>,<span class="stringliteral">"type"</span>))
01128                 {
01129                         <span class="keywordflow">if</span>(strcmp(value, <span class="stringliteral">"FIXED"</span>) == 0)
01130                                 seg.<a class="code" href="structenvelope__segment.html#o3">lengthType</a> = <a class="code" href="Types_8h.html#a12a7">FIXED</a>;
01131                         <span class="keywordflow">if</span>(strcmp(value, <span class="stringliteral">"FLEXIBLE"</span>) == 0)
01132                                 seg.<a class="code" href="structenvelope__segment.html#o3">lengthType</a> = <a class="code" href="Types_8h.html#a12a8">FLEXIBLE</a>;
01133                 }
01134                 segmentCollection.<a class="code" href="classCollection.html#a4">add</a>(seg);
01135         }
01136         
01137         <a class="code" href="classEnvelope.html#a8">DefineShape</a>(segmentCollection);
01138 }
01139 
01140 <span class="comment">//----------------------------------------------------------------------------//</span>
01141 <span class="preprocessor">#endif //__ENVELOPE_CPP</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Apr 25 13:18:11 2005 for LASS by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
