LASS User’s Manual

	LASS is an object-oriented additive sound synthesis library written largely in C++ which takes full advantage of the modularity of object-oriented programming. It is in continual development at the Computer Music Project (CMP) of the University of Illinois Experimental Music Studios (EMS).

Tutorial

	We will begin with a tutorial of the most basic components used in creating sounds with examples of code usage. Some knowledge of C++ is assumed. More detailed functionality and reference is given in the comprehensive section that follows this one.
Header

	There is a general purpose header that includes all relevant LASS files. Include it at the beginning of your code and you won’t need any other LASS specific headers:

#include "lib.h"

Sound

	A Sound is a Collection of Partials (see Collection for details of its methods).
	
	The most common constructor for Sound is:

Sound::Sound (int numPartials, m_value_type baseFreq);
Sound my_sound (4, 440);

where numPartials is at least 1 and the baseFreq corresponds to the frequency of the fundamental or lowest Partial (0) in Hertz. By default, higher number Partials are constructed at multiple frequencies of the fundamental. This is modified through the use of Detuning (see Other Sound and Partial parameters).

         Some general parameters for a Sound can be set with:

Sound::setParam (StaticT p, m_value_type v);
my_sound.setParam (LOUDNESS, 200);

where p is one of Sound’s parameters that can be modified and v is a value that corresponds to that parameter.  Some essential parameters that you will want to modify with Sound are:

* START_TIME: The time in seconds at which a Sound will begin playing counted from the beginning of the piece (represented by a Score, see Score).
* DURATION: The time in seconds a Sound lasts after it begins playing.
* LOUDNESS: The desired loudness of the sound, from 0 (silent) to 256 (maximum volume) in Sones (see Appendix for a definition of Sones).

Panning and Reverb (see Panning and Reverb), in addition to numerous Partial parameters (see Partial) can also be applied to a Sound. Detuning is also available (see Other Sound and Partial parameters).

Partial

         A Partial is the basic constituent of a Sound. There is a wide range of Partial parameters that can be specified including Tremolo (AM), Vibrato (FM), Glissando, and Reverb (see Reverb and Other Sound and Partial parameters). There are also Partial constructors for creating and adding Partials individually to a Sound. Some essential parameters that you will want to modify with Partial are:

* RELATIVE_AMPLITUDE: A number that specifies a loudness relative to other Partials within a Sound. The number can be any value relative to the range of values although values between 0 and 1, with 1 being assigned to the fundamental, are recommended.

These two are often set for all Partials in a Sound at once, although they can also be set for individual Partials:
* WAVE_SHAPE: This is an envelope whose shape is structured by the user. In LASS this envelope is called a DynamicVariableSequence (see DynamicVariableSequence for instruction on creating envelopes).
* FREQUENCY_DEVIATION: This modifies the harmonic spectrum (Partial frequencies are integer multiples of the fundamental frequency) by a random factor. The range is from 0 (harmonic tuning) to 1 (maximum deviation—a Sound whose spectrum resembles more that of untuned percussive instruments. For a FREQUENCY_DEVIATION of 1, the frequency range spans the distance between the midpoints of this Partial and the neighboring higher and lower Partials).

     All of the Partials’ parameters in a Sound can be set at once with:

Sound::setPartialParam (PartialDynamicParam p, m_value_type v);
my_sound.setPartialParam (FREQUENCY_DEVIATION, 0.05);

or individually with the syntax:

my_sound.get(0).setParam (RELATIVE_AMPLITUDE, 1.00);

where the number in get(0) specifies the Partial whose parameter you wish to set. get is a method of the Collection class (this corresponds to: Partial::setParam (PartialDynamicParam p, m_value_type v); as Sound is a Collection of Partials, see Collection).

Score

	A Score is a Collection of Sounds (see Collection for details of its methods) and is the level at which rendering takes place. A Score is the equivalent of a notated composition. 

	The constructor for Score is simply:

Score::Score ();
Score my_score;

and Sounds are added to the Score (after having been previously created with Partials and a base frequency and assigned at least a START_TIME, DURATION, and LOUDNESS, see Sound, above) with the following syntax:

my_score.add (my_sound);

	Add is a method of the Collection class (see Collection for details of its methods). In this context, it takes a Sound object as a parameter.

	There are six clipping management modes (see Clipping Management for usage) from which NONE is selected by default if left unspecified (no clipping management applied).

Rendering a Score
	
	In order to render a Score to an audio file (LASS supports the Sun audiofile .au format), the Score::render method is called:

MultiTrack* Score::render (int numChannels,
         m_rate_type samplingRate = DEFAULT_SAMPLING_RATE);
MultiTrack* my_rendered_score = my_score.render (2, 44100);

         numChannels is the number of channels the Score should render to (2 is stereo) and samplingRate is the number of samples per second in Hertz (44100 is CD quality). A pointer to a MultiTrack object is returned which can then be passed as a (dereferenced) parameter to the AuWriter::write method:

static bool AuWriter::write (MultiTrack& mt, string filename);
AuWriter::write (*my_rendered_score, "my_audio_file.au");
         
mt is a MultiTrack reference and filename a string containing the desired output file name.
         
         Note that the MultiTrack object is dynamically allocated by Score::render. It is the user’s responsibility to free the memory allocated by the MultiTrack object when it is not needed anymore (after rendering):
         
delete my_rendered_score;

DynamicVariableSequence

	A DynamicVariableSequence is used to specify a generic envelope of y-values over a range of x-values (over time) that can have many applications in LASS. We will look at a common usage, the specifying of WAVE_SHAPE for the Partials in a Sound.

	The following variable initializations are needed when creating DynamicVariableSequences from scratch (see Collection for reference and also The Envelope Library for managing DynamicVariableSequences):

Collection <xy_point> my_point_collection;
Collection <envelope_segment> my_segment_collection;
xy_point my_point;
envelope_segment my_segment;

	A point for a WAVE_SHAPE is specified by an x-value and a y-value, where the x-values specify a sequential arrangement (in time). The point can be created and added to the Collection of points as follows:

my_point.x = 0.0; my_point.y = 0.0;
my_point_collection.add (my_point);

	A segment for a WAVE_SHAPE interpolates data between two x-value points. For every n points, there should be n-1 segments, otherwise DynamicVariableSequence will complain about the inconsistency. A segment consists of an interpolation type, a time type and a time value and is created and added to the Collection of segments as follows:

my_segment.interType = LINEAR; 
my_segment.timeType = FIXED; 
my_segment.timeValue = 1;
my_segment_collection.add (my_segment);

	There are three segment interpolation types provided by LASS:

* LINEAR: Two points are connected linearly (constant slope).
* EXPONENTIAL: Two points are connected exponentially (exponential slope).
* CUBIC_SPLINE: Interpolation is made between two points based on the slopes existing between them and their nearest neighbors (continuous curvature).

     There are two types of segment time types for DynamicVariableSequences which have the following properties:

* FIXED: FIXED type segments are kept constant, as declared or are scaled as a percentage of their sum if the total length (duration) is not equal to their sum.
* FLEXIBLE: FLEXIBLE type segments are scaled according to the total length (duration) of the envelope.
         
	The segment time value is a percentage of the sum of the segment time values of its time type in a DynamicVariableSequence. If the sum of all FIXED type segment time values is more than the DURATION of the Sound, it will be scaled down to fit the DURATION of the Sound when the Sound is rendered, any FLEXIBLE type segments will be disregarded and a warning will be issued. If the sum of all FIXED type segment time values is less than the DURATION of the Sound, there will be room for FLEXIBLE segment type scaling, or if there are no FLEXIBLE type segments, the FIXED type segment time values will be scaled up to fit the DURATION of the Sound when the Sound is rendered. If FIXED and FLEXIBLE type segments are used together, it is probably desirable to have an idea of the DURATION of the Sound the DynamicVariableSequence is being applied to, so that time will be left to fit the FLEXIBLE time type segments, and so that the time values can correspond to the Sound DURATION.

	Once the Collections of points have been created, they can be used to construct a DynamicVariableSequence using the following constructor:

DynamicVariableSequence::DynamicVariableSequence (
    	Collection <xy_point> xyPoints,
         Collection <envelope_segment> segments)
DynamicVariableSequence my_DVS (
         my_point_collection, 
my_segment_collection);

and assigned to the Partials of a Sound with:

my_sound.setPartialParam (WAVE_SHAPE, my_DVS);

	The Collections of points and segments must be cleared before a new DynamicVariableSequence can be constructed. This is done as follows:

my_point_collection.clear ();
my_segment_collection.clear ();

Panning
	
	Panning implements spatialization across the number of audio channels specified when rendering a Score. Panning can be applied to Sounds. 

         First, a Panning envelope must be created using a DynamicVariableSequence (see A simple program for an example). A Pan object is created using the following constructor:

Pan::Pan (DynamicVariable& v);
Pan my_pan (DVS_pan_envelope);

and assigned to a Sound with this syntax:

void setSpatializer (Spatializer& s);
my_sound.setSpatializer (my_pan);

Multipan

	Multipan implements precisely controlled spatialization over an arbitrary number of speakers for a given Sound.

         A Multipan object is created with the following constructor:

MultiPan::MultiPan (int nChans)
MultiPan my_multipan (5);

         There are two ways to implement this. The first method is to map the panning directly to the speakers using the addEntry method:
         
void MultiPan::addEntry (float t, ...)
my_multipan.addEntry (0.000, 1.000, 0.000, 0.000, 0.000, 0.000);

where the first parameter, t, represents the time as a percentage of the duration of the Sound at which the panning is applied, and the following parameters represent the ratio of application for each speaker.

The second method is to map to speakers evenly separated in a circle about a hypothetical listener using polar coordinates.  The math.h header should be included for the use of M_PI:

#include <math.h>

and the addEntryLocation method is used to position the sound within that circle:

void MultiPan::addEntryLocation (float t, float theta, float radius)
my_multipan.addEntryLocation (0.00, M_PI/4.0, 0.4);

where t represents the time as a percentage of the duration of the Sound at which the panning is applied, theta represents the angle at which the Sound emanates from (positive angles to the left and negative angles to the right, 0 directly in front of the listener and ±M_PI directly behind the listener), and radius represents the distance between the listener (0) and the edge of the speaker circle (1) from which the Sound emanates.

	The Multipan object is assigned to a Sound with this syntax:

void setSpatializer (Spatializer& s);
my_sound.setSpatializer (my_multipan);

and the output can be written to each separate channel during rendering with the AuWriter::write_one_per_track method (as opposed to the AuWriter::write method, see Rendering a Score):

bool AuWriter::write_one_per_track (MultiTrack& mt,
         char *filename, ...)
AuWriter::write_one_per_track (*my_renderedScore, 
				"my_audio_chan0.au",
				"my_audio_chan1.au",
				"my_audio_chan2.au",
				"my_audio_chan3.au",
				"my_audio_chan4.au");

Reverb

	Reverb implements an artificial reverberator. Reverb can be applied to Partials, Sounds, or Scores.

	There are several constructors for a Reverb object (see 2. Reverb for full reference), one of the more basic being:

Reverb::Reverb (float room_size, m_rate_type samplingRate);
Reverb *my_reverb = new Reverb (0.3, 44100);

where room_size is a value between 0 (virtually no reverberation) and 1 which emulates the type of space in which the Reverb occurs. samplingRate should correspond to the sampling rate at which the Score is rendered (see Rendering a Score).

	Reverb is applied to a Partial, Sound, or Score with the use_reverb method:

void Score::use_reverb (Reverb *newReverbObj)
my_score.use_reverb (my_reverb);

where newReverbObj is a pointer to a Reverb object.

	Note in the constructor above that the Reverb object is dynamically allocated. It is the user’s responsibility to free the memory allocated by the Reverb object when it is not needed anymore (after rendering):

delete my_reverb;

Clipping Management

	In order to apply Clipping Management to a rendered Score, the manageClipping method is used. It has the following syntax:

void Score::manageClipping (MultiTrack* mt,
         ClippingManagementMode mode)
Score::manageClipping (my_rendered_score, Score::CLIP);

This takes places after rendering the Score with Score::render and before writing to a file AuWriter::write (see Rendering a Score). 

         The following clipping modes are supported:

* NONE: No clipping management is used (default).
* CLIP: Any value over or under a maximum constant threshold is clipped to that threshold.
* SCALE: The maximum amplitude is evaluated for the entire Score and the Score is scaled by 1 / (maximum amplitude).
* CHANNEL-SCALE: Amplitude scaling is done as per SCALE but for each channel individually rather than for the entire Score.
* ANTICLIP: The maximum amplitude is evaluated at each sample and if a sample exceeds the maximum constant threshold, it is scaled by (maximum constant threshold) / (maximum amplitude). This is evaluated for the entire Score.
* CHANNEL-ANTICLIP: As per ANTICLIP but for each channel individually rather than for the entire Score.

Other Sound and Partial Parameters

	There are a variety of other Sound and Partial parameters which are useful in working with Sounds.  

    Detuning is implemented within Sound, following the Sound::setParam syntax (see Sound). Detuning describes the effect of the Partials in a Sound either converging to or diverging from their intended frequencies. Detuning uses the following parameters:

* DETUNE_SPREAD: A range from which the frequency at the beginning of convergence or end of divergence is randomly selected. It is calculated using the formula (1.0 ± DETUNE_SPREAD) * the Partial frequency. The parameter should take a value between 0 and 1.
* DETUNE_DIRECTION: -1 = divergence (detuning), +1 = convergence (tuning)
* DETUNE_VELOCITY: A value between -1 and +1 which signifies the curvature of the detuning over the envelope of the Partial. Values near -1 begin to converge or diverge at the beginning of the envelope, and values near +1 toward the end of the envelope. .5 is a linear convergence or divergence.
* DETUNE_FUNDAMENTAL: -1 = do not tune or detune the fundamental Partial, +1 = tune or detune all Partials.

Tremolo (AM modulation), Vibrato (FM modulation), and Glissando can be implemented at the Sound or Partial level (see Partial for syntax). The parameters are as follows:

* TREMOLO_AMP: The amplitude of the Tremolo as a scaling factor to the amplitude of the Partial.
* TREMOLO_RATE: Rate of Tremolo in Hertz.
* VIBRATO_AMP: The amplitude of the Vibrato as a scaling factor to the frequency of the Partial.
* VIBRATO_RATE: Rate of the Vibrato in Hertz.
* GLISSANDO_ENV: A DynamicVariableSequence which describes change in frequency over time as a scaling factor to the frequency. An unmodified frequency corresponds to a value of 1.

The Envelope Library

	The Envelope Library provides library functionality for DynamicVariableSequences. Envelope Library is created with the following constructor:

EnvelopeLibrary::EnvelopeLibrary ()
EnvelopeLibrary my_library;

	DynamicVariableSequences are added to the library with addEnvelope either as Collections of points and segments (see DynamicVariableSequence), or as a pointer to a DynamicVariableSequence:

int EnvelopeLibrary::addEnvelope (Collection <xy_point> points,
         Collection <envelope_segment> segments)
my_library.addEnvelope (my_point_collection, my_segment_collection);

int EnvelopeLibrary::addEnvelope (DynamicVariableSequence * dvs)
DynamicVariableSequence * my_DVS = new DynamicVariableSequence
	(my_point_collection, my_segment_collection);
int size = my_library.addEnvelope (my_DVS);

The new size of the library is returned as an int.

	A particular DynamicVariableSequence can be updated in the library with updateEnvelope:

bool EnvelopeLibrary::updateEnvelope 
         (int index, DynamicVariableSequence * dvs)
bool success = my_library.updateEnvelope (1, my_DVS);

where index corresponds to the sequential library entry. A pointer to a DynamicVariableSequence object is passed to the method. true is returned as a bool on a successful update.

	DynamicVariableSequences can be copied from the library into a DynamicVariableSequence pointer with getEnvelope: 

DynamicVariableSequence * EnvelopeLibrary::getEnvelope (int index)
DynamicVariableSequence * my_DVS = my_library.getEnvelope (1);

where index corresponds to the sequential library entry.

	The values contained in a DynamicVariableSequence can be displayed with showEnvelope:

void EnvelopeLibrary::showEnvelope (int index)
my_library.showEnvelope (1);

where index corresponds to the sequential library entry.

	The functions associated with loading and saving the library to a disk file are loadLibrary and saveLibrary:

int EnvelopeLibrary::loadLibrary (char * filename)
int size = my_library.loadLibrary (“my_library_file”);

where the size of the library is returned as an int.

bool EnvelopeLibrary::saveLibrary (char * filename)
bool success = my_library.saveLibrary (“my_library_file”);

where true is returned as a bool on a successful save.

	There is also a method, size to return the size of the library as an int:

int EnvelopeLibrary::size ()
int size = my_library.size ();

Collection

        Sound and Score, in particular, inherit from the Collection class. Some methods from Collection used in this tutorial are described here.

When adding Partials to a Sound or Sounds to a Score, the add method is used:

template <class T> void Collection<T>::add (const T& element)
my_score.add (my_sound);

When selecting a Partial for modification from a Sound, the get method is used:

template <class T> T& Collection<T>::get (int index)
my_sound.get(0).setParam (RELATIVE_AMPLITUDE, 1.00);

Other methods and constructors are available for use of Collections, including functionality for adding by index, deleting, replacing, and sorting data.

A simple program

// comprehensive header
#include "lib.h"

int main (int argc, const char * argv[]) {

    // DynamicVariableSequence initializations
    Collection <xy_point> my_point_collection;
    Collection<envelope_segment> my_segment_collection;
    xy_point my_point;
    envelope_segment my_segment;

    // point and segment Collection creation
    my_point.x = 0.0; my_point.y = 0.0;
    my_point_collection.add (my_point);
    my_point.x = 0.2; my_point.y = 0.8;
    my_point_collection.add (my_point);
    my_point.x = 0.4; my_point.y = 0.5;
    my_point_collection.add (my_point);
    my_point.x = 1.0; my_point.y = 0.0;
    my_point_collection.add (my_point);

    seg.interType = LINEAR; seg.timeType = FIXED; seg.timeValue = 1;
    my_segment_collection.add (my_segment);
    seg.interType = LINEAR; seg.timeType = FIXED; seg.timeValue = 1;
    my_segment_collection.add (my_segment);
    seg.interType = LINEAR; seg.timeType = FIXED; seg.timeValue = 3;
    my_segment_collection.add (my_segment);

    // create a DynamicVariableSequence from Collections
    DynamicVariableSequence my_DVS (
        my_point_collection, my_segment_collection);

    // create a Sound
    Sound my_sound (4,440);

    // adjust the RELATIVE_AMPLITUDE of the Partials
    my_sound.get (0).setParam (RELATIVE_AMPLITUDE, 1.00);
    my_sound.get (1).setParam (RELATIVE_AMPLITUDE, 0.30);
    my_sound.get (2).setParam (RELATIVE_AMPLITUDE, 0.10);
    my_sound.get (3).setParam (RELATIVE_AMPLITUDE, 0.05);

    // assign WAVE_SHAPE and FREQUENCY_DEVIATION
    // to all partials in this Sound
    my_sound.setPartialParam (WAVE_SHAPE, my_DVS);
    my_sound.setPartialParam (FREQUENCY_DEVIATION, 0.05);

    // set this Sound’s duration and loudness
    my_sound.setParam (DURATION, 1.2);
    my_sound.setParam (LOUDNESS, 200);

    // clear the collections in order to construct a fresh envelope
    my_point_collection.clear ();
    my_segment_collection.clear ();

    // point and segment Collection creation (for Pan)
    my_point.x = 0.0; my_point.y = 0.0;
    my_point_collection.add (my_point);
    my_point.x = 1.0; my_point.y = 1.0;
    my_point_collection.add (my_point);

    seg.interType = LINEAR; seg.timeType = FIXED; seg.timeValue = 1;
    my_segment_collection.add (my_segment);

    // create a DynamicVariableSequence with Collections
    DynamicVariableSequence pan_left_to_right (
           my_point_collection, my_segment_collection);

    // create a Pan object and apply it to the Sound
    Pan my_pan (pan_left_to_right);
    my_sound.setSpatializer (my_pan);

    // create a Reverb object and apply it to the Sound
    Reverb *my_reverb = new Reverb (0.3, 44100);
    my_sound.use_reverb (my_reverb);

    // create a Score
    Score my_score;

    // set the start time for the Sound	
    my_sound.setParam (START_TIME, 0.0);
    
    // add the Sound to the Score
    my_score.add (my_sound);

    // Render in two channels (stereo), 44100 Hz
    MultiTrack* my_rendered_score = my_score.render (2,44100);
    
    // write the Rendered Score to a file
    AuWriter::write (*my_rendered_score, "my_audio_file.au");
    
    delete my_rendered_score;
    delete my_reverb;
}

Appendix

Definition of Sones:


Philipp Fraund
January 2004
fraund@uiuc.edu
